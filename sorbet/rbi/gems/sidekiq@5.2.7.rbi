# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sidekiq` gem.
# Please instead update this file by running `bin/tapioca gem sidekiq`.

# source://sidekiq//lib/sidekiq/version.rb#2
module Sidekiq
  class << self
    # How frequently Redis should be checked by a random Sidekiq process for
    # scheduled and retriable jobs. Each individual process will take turns by
    # waiting some multiple of this value.
    #
    # See sidekiq/scheduled.rb for an in-depth explanation of this value
    #
    # source://sidekiq//lib/sidekiq.rb#199
    def average_scheduled_poll_interval=(interval); end

    # @yield [@client_chain]
    #
    # source://sidekiq//lib/sidekiq.rb#137
    def client_middleware; end

    # Configuration for Sidekiq client, use like:
    #
    #   Sidekiq.configure_client do |config|
    #     config.redis = { :namespace => 'myapp', :size => 1, :url => 'redis://myhost:8877/0' }
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq//lib/sidekiq.rb#84
    def configure_client; end

    # Configuration for Sidekiq server, use like:
    #
    #   Sidekiq.configure_server do |config|
    #     config.redis = { :namespace => 'myapp', :size => 25, :url => 'redis://myhost:8877/0' }
    #     config.server_middleware do |chain|
    #       chain.add MyServerHook
    #     end
    #   end
    #
    # @yield [_self]
    # @yieldparam _self [Sidekiq] the object that the method was called on
    #
    # source://sidekiq//lib/sidekiq.rb#74
    def configure_server; end

    # Death handlers are called when all retries for a job have been exhausted and
    # the job dies.  It's the notification to your application
    # that this job will not succeed without manual intervention.
    #
    # Sidekiq.configure_server do |config|
    #   config.death_handlers << ->(job, ex) do
    #   end
    # end
    #
    # source://sidekiq//lib/sidekiq.rb#176
    def death_handlers; end

    # source://sidekiq//lib/sidekiq.rb#161
    def default_retries_exhausted=(prok); end

    # source://sidekiq//lib/sidekiq.rb#149
    def default_server_middleware; end

    # source://sidekiq//lib/sidekiq.rb#157
    def default_worker_options; end

    # source://sidekiq//lib/sidekiq.rb#153
    def default_worker_options=(hash); end

    # source://sidekiq//lib/sidekiq.rb#183
    def dump_json(object); end

    # Register a proc to handle any error which occurs within the Sidekiq process.
    #
    #   Sidekiq.configure_server do |config|
    #     config.error_handlers << proc {|ex,ctx_hash| MyErrorService.notify(ex, ctx_hash) }
    #   end
    #
    # The default error handler logs errors to Sidekiq.logger.
    #
    # source://sidekiq//lib/sidekiq.rb#210
    def error_handlers; end

    # source://sidekiq//lib/sidekiq.rb#180
    def load_json(string); end

    # source://sidekiq//lib/sidekiq.rb#187
    def logger; end

    # source://sidekiq//lib/sidekiq.rb#190
    def logger=(log); end

    # Register a block to run at a point in the Sidekiq lifecycle.
    # :startup, :quiet or :shutdown are valid events.
    #
    #   Sidekiq.configure_server do |config|
    #     config.on(:shutdown) do
    #       puts "Goodbye cruel world!"
    #     end
    #   end
    #
    # @raise [ArgumentError]
    #
    # source://sidekiq//lib/sidekiq.rb#222
    def on(event, &block); end

    # source://sidekiq//lib/sidekiq.rb#57
    def options; end

    # source://sidekiq//lib/sidekiq.rb#61
    def options=(opts); end

    # @raise [ArgumentError]
    #
    # source://sidekiq//lib/sidekiq.rb#92
    def redis; end

    # source://sidekiq//lib/sidekiq.rb#129
    def redis=(hash); end

    # source://sidekiq//lib/sidekiq.rb#107
    def redis_info; end

    # source://sidekiq//lib/sidekiq.rb#125
    def redis_pool; end

    # @return [Boolean]
    #
    # source://sidekiq//lib/sidekiq.rb#88
    def server?; end

    # @yield [@server_chain]
    #
    # source://sidekiq//lib/sidekiq.rb#143
    def server_middleware; end

    # source://sidekiq//lib/sidekiq.rb#53
    def ❨╯°□°❩╯︵┻━┻; end
  end
end

# source://sidekiq//lib/sidekiq/client.rb#6
class Sidekiq::Client
  # Sidekiq::Client normally uses the default Redis pool but you may
  # pass a custom ConnectionPool if you want to shard your
  # Sidekiq jobs across several Redis instances (for scalability
  # reasons, e.g.)
  #
  #   Sidekiq::Client.new(ConnectionPool.new { Redis.new })
  #
  # Generally this is only needed for very large Sidekiq installs processing
  # thousands of jobs per second.  I don't recommend sharding unless you
  # cannot scale any other way (e.g. splitting your app into smaller apps).
  #
  # @return [Client] a new instance of Client
  #
  # source://sidekiq//lib/sidekiq/client.rb#41
  def initialize(redis_pool = T.unsafe(nil)); end

  # Define client-side middleware:
  #
  #   client = Sidekiq::Client.new
  #   client.middleware do |chain|
  #     chain.use MyClientMiddleware
  #   end
  #   client.push('class' => 'SomeWorker', 'args' => [1,2,3])
  #
  # All client instances default to the globally-defined
  # Sidekiq.client_middleware but you can change as necessary.
  #
  # source://sidekiq//lib/sidekiq/client.rb#20
  def middleware(&block); end

  # The main method used to push a job to Redis.  Accepts a number of options:
  #
  #   queue - the named queue to use, default 'default'
  #   class - the worker class to call, required
  #   args - an array of simple arguments to the perform method, must be JSON-serializable
  #   at - timestamp to schedule the job (optional), must be Numeric (e.g. Time.now.to_f)
  #   retry - whether to retry this job if it fails, default true or an integer number of retries
  #   backtrace - whether to save any error backtrace, default false
  #
  # If class is set to the class name, the jobs' options will be based on Sidekiq's default
  # worker options. Otherwise, they will be based on the job class's options.
  #
  # Any options valid for a worker class's sidekiq_options are also available here.
  #
  # All options must be strings, not symbols.  NB: because we are serializing to JSON, all
  # symbols in 'args' will be converted to strings.  Note that +backtrace: true+ can take quite a bit of
  # space in Redis; a large volume of failing jobs can start Redis swapping if you aren't careful.
  #
  # Returns a unique Job ID.  If middleware stops the job, nil will be returned instead.
  #
  # Example:
  #   push('queue' => 'my_queue', 'class' => MyWorker, 'args' => ['foo', 1, :bat => 'bar'])
  #
  # source://sidekiq//lib/sidekiq/client.rb#69
  def push(item); end

  # Push a large number of jobs to Redis. This method cuts out the redis
  # network round trip latency.  I wouldn't recommend pushing more than
  # 1000 per call but YMMV based on network quality, size of job args, etc.
  # A large number of jobs can cause a bit of Redis command processing latency.
  #
  # Takes the same arguments as #push except that args is expected to be
  # an Array of Arrays.  All other keys are duplicated for each job.  Each job
  # is run through the client middleware pipeline and each job gets its own Job ID
  # as normal.
  #
  # Returns an array of the of pushed jobs' jids.  The number of jobs pushed can be less
  # than the number given if the middleware stopped processing for one or more jobs.
  #
  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/client.rb#92
  def push_bulk(items); end

  # Returns the value of attribute redis_pool.
  #
  # source://sidekiq//lib/sidekiq/client.rb#29
  def redis_pool; end

  # Sets the attribute redis_pool
  #
  # @param value the value to set the attribute redis_pool to.
  #
  # source://sidekiq//lib/sidekiq/client.rb#29
  def redis_pool=(_arg0); end

  private

  # source://sidekiq//lib/sidekiq/client.rb#191
  def atomic_push(conn, payloads); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/client.rb#217
  def normalize_item(item); end

  # source://sidekiq//lib/sidekiq/client.rb#234
  def normalized_hash(item_class); end

  # source://sidekiq//lib/sidekiq/client.rb#209
  def process_single(worker_class, item); end

  # source://sidekiq//lib/sidekiq/client.rb#182
  def raw_push(payloads); end

  class << self
    # Resque compatibility helpers.  Note all helpers
    # should go through Worker#client_push.
    #
    # Example usage:
    #   Sidekiq::Client.enqueue(MyWorker, 'foo', 1, :bat => 'bar')
    #
    # Messages are enqueued to the 'default' queue.
    #
    # source://sidekiq//lib/sidekiq/client.rb#147
    def enqueue(klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_in(3.minutes, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#175
    def enqueue_in(interval, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to(:queue_name, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#154
    def enqueue_to(queue, klass, *args); end

    # Example usage:
    #   Sidekiq::Client.enqueue_to_in(:queue_name, 3.minutes, MyWorker, 'foo', 1, :bat => 'bar')
    #
    # source://sidekiq//lib/sidekiq/client.rb#161
    def enqueue_to_in(queue, interval, klass, *args); end

    # source://sidekiq//lib/sidekiq/client.rb#131
    def push(item); end

    # source://sidekiq//lib/sidekiq/client.rb#135
    def push_bulk(items); end

    # Allows sharding of jobs across any number of Redis instances.  All jobs
    # defined within the block will use the given Redis connection pool.
    #
    #   pool = ConnectionPool.new { Redis.new }
    #   Sidekiq::Client.via(pool) do
    #     SomeWorker.perform_async(1,2,3)
    #     SomeOtherWorker.perform_async(1,2,3)
    #   end
    #
    # Generally this is only needed for very large Sidekiq installs processing
    # thousands of jobs per second.  I do not recommend sharding unless
    # you cannot scale any other way (e.g. splitting your app into smaller apps).
    #
    # source://sidekiq//lib/sidekiq/client.rb#120
    def via(pool); end
  end
end

# source://sidekiq//lib/sidekiq.rb#18
Sidekiq::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq.rb#40
Sidekiq::DEFAULT_WORKER_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq/delay.rb#3
module Sidekiq::Extensions
  class << self
    # source://sidekiq//lib/sidekiq/delay.rb#5
    def enable_delay!; end
  end
end

# source://sidekiq//lib/sidekiq/delay.rb#26
module Sidekiq::Extensions::PsychAutoload
  # source://sidekiq//lib/sidekiq/delay.rb#27
  def resolve_class(klass_name); end
end

# source://sidekiq//lib/sidekiq.rb#45
Sidekiq::FAKE_INFO = T.let(T.unsafe(nil), Hash)

# source://sidekiq//lib/sidekiq.rb#16
Sidekiq::LICENSE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/logging.rb#7
module Sidekiq::Logging
  # source://sidekiq//lib/sidekiq/logging.rb#118
  def logger; end

  class << self
    # source://sidekiq//lib/sidekiq/logging.rb#53
    def initialize_logger(log_target = T.unsafe(nil)); end

    # source://sidekiq//lib/sidekiq/logging.rb#33
    def job_hash_context(job_hash); end

    # source://sidekiq//lib/sidekiq/logging.rb#62
    def logger; end

    # source://sidekiq//lib/sidekiq/logging.rb#66
    def logger=(log); end

    # This reopens ALL logfiles in the process that have been rotated
    # using logrotate(8) (without copytruncate) or similar tools.
    # A +File+ object is considered for reopening if it is:
    #   1) opened with the O_APPEND and O_WRONLY flags
    #   2) the current open file handle does not match its original open path
    #   3) unbuffered (as far as userspace buffering goes, not O_SYNC)
    # Returns the number of files reopened
    #
    # source://sidekiq//lib/sidekiq/logging.rb#77
    def reopen_logs; end

    # source://sidekiq//lib/sidekiq/logging.rb#29
    def tid; end

    # source://sidekiq//lib/sidekiq/logging.rb#45
    def with_context(msg); end

    # source://sidekiq//lib/sidekiq/logging.rb#41
    def with_job_hash_context(job_hash, &block); end
  end
end

# source://sidekiq//lib/sidekiq/logging.rb#9
class Sidekiq::Logging::Pretty < ::Logger::Formatter
  # Provide a call() method that returns the formatted message.
  #
  # source://sidekiq//lib/sidekiq/logging.rb#13
  def call(severity, time, program_name, message); end

  # source://sidekiq//lib/sidekiq/logging.rb#17
  def context; end
end

# source://sidekiq//lib/sidekiq/logging.rb#10
Sidekiq::Logging::Pretty::SPACE = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/logging.rb#23
class Sidekiq::Logging::WithoutTimestamp < ::Sidekiq::Logging::Pretty
  # source://sidekiq//lib/sidekiq/logging.rb#24
  def call(severity, time, program_name, message); end
end

# Middleware is code configured to run before/after
# a message is processed.  It is patterned after Rack
# middleware. Middleware exists for the client side
# (pushing jobs onto the queue) as well as the server
# side (when jobs are actually processed).
#
# To add middleware for the client:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.add MyClientHook
#   end
# end
#
# To modify middleware for the server, just call
# with another block:
#
# Sidekiq.configure_server do |config|
#   config.server_middleware do |chain|
#     chain.add MyServerHook
#     chain.remove ActiveRecord
#   end
# end
#
# To insert immediately preceding another entry:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.insert_before ActiveRecord, MyClientHook
#   end
# end
#
# To insert immediately after another entry:
#
# Sidekiq.configure_client do |config|
#   config.client_middleware do |chain|
#     chain.insert_after ActiveRecord, MyClientHook
#   end
# end
#
# This is an example of a minimal server middleware:
#
# class MyServerHook
#   def call(worker_instance, msg, queue)
#     puts "Before work"
#     yield
#     puts "After work"
#   end
# end
#
# This is an example of a minimal client middleware, note
# the method must return the result or the job will not push
# to Redis:
#
# class MyClientHook
#   def call(worker_class, msg, queue, redis_pool)
#     puts "Before push"
#     result = yield
#     puts "After push"
#     result
#   end
# end
#
# source://sidekiq//lib/sidekiq/middleware/chain.rb#66
module Sidekiq::Middleware; end

# source://sidekiq//lib/sidekiq/middleware/chain.rb#67
class Sidekiq::Middleware::Chain
  include ::Enumerable

  # @return [Chain] a new instance of Chain
  # @yield [_self]
  # @yieldparam _self [Sidekiq::Middleware::Chain] the object that the method was called on
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#79
  def initialize; end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#88
  def add(klass, *args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#120
  def clear; end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#75
  def each(&block); end

  # Returns the value of attribute entries.
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#69
  def entries; end

  # @return [Boolean]
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#112
  def exists?(klass); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#105
  def insert_after(oldklass, newklass, *args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#98
  def insert_before(oldklass, newklass, *args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#124
  def invoke(*args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#93
  def prepend(klass, *args); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#84
  def remove(klass); end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#116
  def retrieve; end

  private

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#71
  def initialize_copy(copy); end
end

# source://sidekiq//lib/sidekiq/middleware/chain.rb#137
class Sidekiq::Middleware::Entry
  # @return [Entry] a new instance of Entry
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#140
  def initialize(klass, *args); end

  # Returns the value of attribute klass.
  #
  # source://sidekiq//lib/sidekiq/middleware/chain.rb#138
  def klass; end

  # source://sidekiq//lib/sidekiq/middleware/chain.rb#145
  def make_new; end
end

# source://sidekiq//lib/sidekiq.rb#15
Sidekiq::NAME = T.let(T.unsafe(nil), String)

# source://sidekiq//lib/sidekiq/rails.rb#11
class Sidekiq::Rails < ::Rails::Engine; end

# source://sidekiq//lib/sidekiq/rails.rb#36
class Sidekiq::Rails::Reloader
  # @return [Reloader] a new instance of Reloader
  #
  # source://sidekiq//lib/sidekiq/rails.rb#37
  def initialize(app = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/rails.rb#41
  def call; end

  # source://sidekiq//lib/sidekiq/rails.rb#47
  def inspect; end
end

# source://sidekiq//lib/sidekiq/redis_connection.rb#7
class Sidekiq::RedisConnection
  class << self
    # source://sidekiq//lib/sidekiq/redis_connection.rb#10
    def create(options = T.unsafe(nil)); end

    private

    # source://sidekiq//lib/sidekiq/redis_connection.rb#52
    def build_client(options); end

    # source://sidekiq//lib/sidekiq/redis_connection.rb#70
    def client_opts(options); end

    # source://sidekiq//lib/sidekiq/redis_connection.rb#111
    def determine_redis_provider; end

    # source://sidekiq//lib/sidekiq/redis_connection.rb#93
    def log_info(options); end

    # Sidekiq needs a lot of concurrent Redis connections.
    #
    # We need a connection for each Processor.
    # We need a connection for Pro's real-time change listener
    # We need a connection to various features to call Redis every few seconds:
    #   - the process heartbeat.
    #   - enterprise's leader election
    #   - enterprise's cron support
    #
    # @raise [ArgumentError]
    #
    # source://sidekiq//lib/sidekiq/redis_connection.rb#48
    def verify_sizing(size, concurrency); end
  end
end

# We are shutting down Sidekiq but what about workers that
# are working on some long job?  This error is
# raised in workers that have not finished within the hard
# timeout limit.  This is needed to rollback db transactions,
# otherwise Ruby's Thread#kill will commit.  See #377.
# DO NOT RESCUE THIS ERROR IN YOUR WORKERS
#
# source://sidekiq//lib/sidekiq.rb#234
class Sidekiq::Shutdown < ::Interrupt; end

# source://sidekiq//lib/sidekiq/version.rb#3
Sidekiq::VERSION = T.let(T.unsafe(nil), String)

# Include this module in your worker class and you can easily create
# asynchronous jobs:
#
#   class HardWorker
#     include Sidekiq::Worker
#
#     def perform(*args)
#       # do some work
#     end
#   end
#
# Then in your Rails app, you can do this:
#
#   HardWorker.perform_async(1, 2, 3)
#
# Note that perform_async is a class method, perform is an instance method.
#
# source://sidekiq//lib/sidekiq/worker.rb#23
module Sidekiq::Worker
  mixes_in_class_methods ::Sidekiq::Worker::ClassMethods

  # Returns the value of attribute jid.
  #
  # source://sidekiq//lib/sidekiq/worker.rb#24
  def jid; end

  # Sets the attribute jid
  #
  # @param value the value to set the attribute jid to.
  #
  # source://sidekiq//lib/sidekiq/worker.rb#24
  def jid=(_arg0); end

  # source://sidekiq//lib/sidekiq/worker.rb#35
  def logger; end

  class << self
    # @private
    # @raise [ArgumentError]
    #
    # source://sidekiq//lib/sidekiq/worker.rb#26
    def included(base); end
  end
end

# The Sidekiq testing infrastructure overrides perform_async
# so that it does not actually touch the network.  Instead it
# stores the asynchronous jobs in a per-class array so that
# their presence/absence can be asserted by your tests.
#
# This is similar to ActionMailer's :test delivery_method and its
# ActionMailer::Base.deliveries array.
#
# Example:
#
#   require 'sidekiq/testing'
#
#   assert_equal 0, HardWorker.jobs.size
#   HardWorker.perform_async(:something)
#   assert_equal 1, HardWorker.jobs.size
#   assert_equal :something, HardWorker.jobs[0]['args'][0]
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   MyMailer.delay.send_welcome_email('foo@example.com')
#   assert_equal 1, Sidekiq::Extensions::DelayedMailer.jobs.size
#
# You can also clear and drain all workers' jobs:
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 0, Sidekiq::Extensions::DelayedModel.jobs.size
#
#   MyMailer.delay.send_welcome_email('foo@example.com')
#   MyModel.delay.do_something_hard
#
#   assert_equal 1, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 1, Sidekiq::Extensions::DelayedModel.jobs.size
#
#   Sidekiq::Worker.clear_all # or .drain_all
#
#   assert_equal 0, Sidekiq::Extensions::DelayedMailer.jobs.size
#   assert_equal 0, Sidekiq::Extensions::DelayedModel.jobs.size
#
# This can be useful to make sure jobs don't linger between tests:
#
#   RSpec.configure do |config|
#     config.before(:each) do
#       Sidekiq::Worker.clear_all
#     end
#   end
#
# or for acceptance testing, i.e. with cucumber:
#
#   AfterStep do
#     Sidekiq::Worker.drain_all
#   end
#
#   When I sign up as "foo@example.com"
#   Then I should receive a welcome email to "foo@example.com"
#
# source://sidekiq//lib/sidekiq/worker.rb#73
module Sidekiq::Worker::ClassMethods
  # source://sidekiq//lib/sidekiq/worker.rb#142
  def client_push(item); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/worker.rb#76
  def delay(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/worker.rb#80
  def delay_for(*args); end

  # @raise [ArgumentError]
  #
  # source://sidekiq//lib/sidekiq/worker.rb#84
  def delay_until(*args); end

  # source://sidekiq//lib/sidekiq/worker.rb#138
  def get_sidekiq_options; end

  # source://sidekiq//lib/sidekiq/worker.rb#92
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/worker.rb#98
  def perform_at(interval, *args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/worker.rb#98
  def perform_in(interval, *args); end

  # source://sidekiq//lib/sidekiq/worker.rb#88
  def set(options); end

  # source://sidekiq//lib/sidekiq/worker.rb#152
  def sidekiq_class_attribute(*attrs); end

  # Allows customization for this type of Worker.
  # Legal options:
  #
  #   queue - use a named queue for this Worker, default 'default'
  #   retry - enable the RetryJobs middleware for this Worker, *true* to use the default
  #      or *Integer* count
  #   backtrace - whether to save any error backtrace in the retry payload to display in web UI,
  #      can be true, false or an integer number of lines to save, default *false*
  #   pool - use the given Redis connection pool to push this type of job to a given shard.
  #
  # In practice, any option is allowed.  This is the main mechanism to configure the
  # options for a specific job.
  #
  # source://sidekiq//lib/sidekiq/worker.rb#125
  def sidekiq_options(opts = T.unsafe(nil)); end

  # source://sidekiq//lib/sidekiq/worker.rb#134
  def sidekiq_retries_exhausted(&block); end

  # source://sidekiq//lib/sidekiq/worker.rb#130
  def sidekiq_retry_in(&block); end
end

# source://sidekiq//lib/sidekiq/worker.rb#74
Sidekiq::Worker::ClassMethods::ACCESSOR_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# This helper class encapsulates the set options for `set`, e.g.
#
#     SomeWorker.set(queue: 'foo').perform_async(....)
#
# source://sidekiq//lib/sidekiq/worker.rb#43
class Sidekiq::Worker::Setter
  # @return [Setter] a new instance of Setter
  #
  # source://sidekiq//lib/sidekiq/worker.rb#44
  def initialize(klass, opts); end

  # source://sidekiq//lib/sidekiq/worker.rb#54
  def perform_async(*args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/worker.rb#60
  def perform_at(interval, *args); end

  # +interval+ must be a timestamp, numeric or something that acts
  #   numeric (like an activesupport time interval).
  #
  # source://sidekiq//lib/sidekiq/worker.rb#60
  def perform_in(interval, *args); end

  # source://sidekiq//lib/sidekiq/worker.rb#49
  def set(options); end
end
