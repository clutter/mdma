# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `bootsnap` gem.
# Please instead update this file by running `bin/tapioca gem bootsnap`.

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#101
module ActiveSupport
  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def parse_json_times; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def parse_json_times=(obj); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def test_order; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def test_order=(obj); end

  class << self
    # source://activesupport/6.0.0/lib/active_support.rb#79
    def eager_load!; end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json(*args, &block); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def escape_html_entities_in_json=(arg); end

    # source://activesupport/6.0.0/lib/active_support/gem_version.rb#5
    def gem_version; end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def json_encoder(*args, &block); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def json_encoder=(arg); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def parse_json_times; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def parse_json_times=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def test_order; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def test_order=(obj); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def time_precision(*args, &block); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def time_precision=(arg); end

    # source://activesupport/6.0.0/lib/active_support.rb#87
    def to_time_preserves_timezone; end

    # source://activesupport/6.0.0/lib/active_support.rb#91
    def to_time_preserves_timezone=(value); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format(*args, &block); end

    # source://activesupport/6.0.0/lib/active_support/json/encoding.rb#8
    def use_standard_json_time_format=(arg); end

    # source://activesupport/6.0.0/lib/active_support/version.rb#7
    def version; end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#102
module ActiveSupport::Dependencies
  extend ::Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def _eager_load_paths; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def _eager_load_paths=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#487
  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def autoload_once_paths; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def autoload_once_paths=(obj); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def autoload_paths; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def autoload_paths=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#469
  def autoloadable_module?(path_suffix); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#664
  def autoloaded?(desc); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def autoloaded_constants; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def autoloaded_constants=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#377
  def clear; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def constant_watch_stack; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def constant_watch_stack=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#653
  def constantize(name); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#366
  def depend_on(file_name, message = T.unsafe(nil)); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def explicitly_unloadable_constants; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def explicitly_unloadable_constants=(obj); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def history; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def history=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#351
  def hook!; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def interlock; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def interlock=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#362
  def load?; end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#505
  def load_file(path, const_paths = T.unsafe(nil)); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#528
  def load_missing_constant(from_mod, const_name); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#476
  def load_once_path?(path); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#435
  def loadable_constants_for_path(path, bases = T.unsafe(nil)); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def loaded; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def loaded=(obj); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def loading; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def loading=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#792
  def log(message); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def logger; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def logger=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#679
  def mark_for_unload(const_desc); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def mechanism; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def mechanism=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#697
  def new_constants_in(*descs); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#428
  def qualified_const_defined?(path); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#520
  def qualified_name_for(mod, name); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#647
  def reference(klass); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#727
  def remove_constant(const); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#600
  def remove_unloadable_constants!; end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#385
  def require_or_load(file_name, const_path = T.unsafe(nil)); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#659
  def safe_constantize(name); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#456
  def search_for_file(path_suffix); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#716
  def to_constant_name(desc); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#357
  def unhook!; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def verbose; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def verbose=(obj); end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#64
  def warnings_on_first_load; end

  # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#131
  def warnings_on_first_load=(obj); end

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#672
  def will_unload?(const_desc); end

  private

  # source://activesupport/6.0.0/lib/active_support/dependencies.rb#800
  def real_mod_name(mod); end

  class << self
    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def _eager_load_paths; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def _eager_load_paths=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def autoload_once_paths; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def autoload_once_paths=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def autoload_paths; end

    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#23
    def autoload_paths=(o); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def autoloaded_constants; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def autoloaded_constants=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def constant_watch_stack; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def constant_watch_stack=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def explicitly_unloadable_constants; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def explicitly_unloadable_constants=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def history; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def history=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def interlock; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def interlock=(obj); end

    # source://activesupport/6.0.0/lib/active_support/dependencies.rb#39
    def load_interlock; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def loaded; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def loaded=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def loading; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def loading=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def logger; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def logger=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def mechanism; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def mechanism=(obj); end

    # source://activesupport/6.0.0/lib/active_support/dependencies.rb#32
    def run_interlock; end

    # source://activesupport/6.0.0/lib/active_support/dependencies.rb#46
    def unload_interlock; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def verbose; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def verbose=(obj); end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#57
    def warnings_on_first_load; end

    # source://activesupport/6.0.0/lib/active_support/core_ext/module/attribute_accessors.rb#124
    def warnings_on_first_load=(obj); end
  end
end

# source://activesupport/6.0.0/lib/active_support/dependencies.rb#644
ActiveSupport::Dependencies::Reference = T.let(T.unsafe(nil), ActiveSupport::Dependencies::ClassCache)

# source://bootsnap//lib/bootsnap/version.rb#2
module Bootsnap
  extend ::Bootsnap

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/bundler.rb#5
  def bundler?; end

  class << self
    # source://bootsnap//lib/bootsnap.rb#11
    def setup(cache_dir:, development_mode: T.unsafe(nil), load_path_cache: T.unsafe(nil), autoload_paths_cache: T.unsafe(nil), disable_trace: T.unsafe(nil), compile_cache_iseq: T.unsafe(nil), compile_cache_yaml: T.unsafe(nil)); end

    # source://bootsnap//lib/bootsnap.rb#39
    def setup_disable_trace; end
  end
end

# source://bootsnap//lib/bootsnap/compile_cache.rb#3
module Bootsnap::CompileCache
  class << self
    # @raise [PermissionError]
    #
    # source://bootsnap//lib/bootsnap/compile_cache.rb#27
    def permission_error(path); end

    # source://bootsnap//lib/bootsnap/compile_cache.rb#7
    def setup(cache_dir:, iseq:, yaml:); end

    # @return [Boolean]
    #
    # source://bootsnap//lib/bootsnap/compile_cache.rb#36
    def supported?; end
  end
end

# source://bootsnap//lib/bootsnap/compile_cache.rb#4
class Bootsnap::CompileCache::Error < ::StandardError; end

# source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#7
module Bootsnap::CompileCache::ISeq
  class << self
    # Returns the value of attribute cache_dir.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#9
    def cache_dir; end

    # Sets the attribute cache_dir
    #
    # @param value the value to set the attribute cache_dir to.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#9
    def cache_dir=(_arg0); end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#63
    def compile_option_updated; end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#29
    def fetch(path, cache_dir: T.unsafe(nil)); end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#38
    def input_to_output(_data, _kwargs); end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#12
    def input_to_storage(_, path, _args); end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#70
    def install!(cache_dir); end

    # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#18
    def storage_to_output(binary, _args); end
  end
end

# source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#42
module Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
  # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#57
  def compile_option=(hash); end

  # source://bootsnap//lib/bootsnap/compile_cache/iseq.rb#43
  def load_iseq(path); end
end

module Bootsnap::CompileCache::Native
  private

  def compile_option_crc32=(_arg0); end
  def coverage_running?; end
  def fetch(_arg0, _arg1, _arg2, _arg3); end

  class << self
    def compile_option_crc32=(_arg0); end
    def coverage_running?; end
    def fetch(_arg0, _arg1, _arg2, _arg3); end
  end
end

# source://bootsnap//lib/bootsnap/compile_cache.rb#5
class Bootsnap::CompileCache::PermissionError < ::Bootsnap::CompileCache::Error; end

class Bootsnap::CompileCache::Uncompilable < ::StandardError; end

# source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#6
module Bootsnap::CompileCache::YAML
  class << self
    # Returns the value of attribute cache_dir.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def cache_dir; end

    # Sets the attribute cache_dir
    #
    # @param value the value to set the attribute cache_dir to.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def cache_dir=(_arg0); end

    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#42
    def init!; end

    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#32
    def input_to_output(data, kwargs); end

    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#10
    def input_to_storage(contents, _, kwargs); end

    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#36
    def install!(cache_dir); end

    # Returns the value of attribute msgpack_factory.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def msgpack_factory; end

    # Sets the attribute msgpack_factory
    #
    # @param value the value to set the attribute msgpack_factory to.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def msgpack_factory=(_arg0); end

    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#21
    def storage_to_output(data, kwargs); end

    # Returns the value of attribute supported_options.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def supported_options; end

    # Sets the attribute supported_options
    #
    # @param value the value to set the attribute supported_options to.
    #
    # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#8
    def supported_options=(_arg0); end
  end
end

# source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#67
module Bootsnap::CompileCache::YAML::Patch
  extend ::Bootsnap::CompileCache::YAML::Patch

  # source://bootsnap//lib/bootsnap/compile_cache/yaml.rb#70
  def load_file(path, *args); end
end

# source://bootsnap//lib/bootsnap/explicit_require.rb#3
module Bootsnap::ExplicitRequire
  class << self
    # source://bootsnap//lib/bootsnap/explicit_require.rb#16
    def from_archdir(feature); end

    # source://bootsnap//lib/bootsnap/explicit_require.rb#12
    def from_rubylibdir(feature); end

    # source://bootsnap//lib/bootsnap/explicit_require.rb#8
    def from_self(feature); end

    # Given a set of gems, run a block with the LOAD_PATH narrowed to include
    # only core ruby source paths and these gems -- that is, roughly,
    # temporarily remove all gems not listed in this call from the LOAD_PATH.
    #
    # This is useful before bootsnap is fully-initialized to load gems that it
    # depends on, without forcing full LOAD_PATH traversals.
    #
    # source://bootsnap//lib/bootsnap/explicit_require.rb#26
    def with_gems(*gems); end
  end
end

# source://bootsnap//lib/bootsnap/explicit_require.rb#4
Bootsnap::ExplicitRequire::ARCHDIR = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/explicit_require.rb#6
Bootsnap::ExplicitRequire::DLEXT = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/explicit_require.rb#5
Bootsnap::ExplicitRequire::RUBYLIBDIR = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap.rb#9
class Bootsnap::InvalidConfiguration < ::StandardError; end

# source://bootsnap//lib/bootsnap/load_path_cache.rb#4
module Bootsnap::LoadPathCache
  class << self
    # Returns the value of attribute autoload_paths_cache.
    #
    # source://bootsnap//lib/bootsnap/load_path_cache.rb#31
    def autoload_paths_cache; end

    # Returns the value of attribute load_path_cache.
    #
    # source://bootsnap//lib/bootsnap/load_path_cache.rb#31
    def load_path_cache; end

    # Returns the value of attribute loaded_features_index.
    #
    # source://bootsnap//lib/bootsnap/load_path_cache.rb#31
    def loaded_features_index; end

    # Returns the value of attribute realpath_cache.
    #
    # source://bootsnap//lib/bootsnap/load_path_cache.rb#31
    def realpath_cache; end

    # source://bootsnap//lib/bootsnap/load_path_cache.rb#34
    def setup(cache_path:, development_mode:, active_support: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://bootsnap//lib/bootsnap/load_path_cache.rb#62
    def supported?; end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache.rb#28
Bootsnap::LoadPathCache::CACHED_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#7
class Bootsnap::LoadPathCache::Cache
  # @return [Cache] a new instance of Cache
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#10
  def initialize(store, path_obj, development_mode: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#100
  def absolute_path?(path); end

  # Try to resolve this feature to an absolute path without traversing the
  # loadpath.
  #
  # @raise [LoadPathCache::FallbackScan]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#47
  def find(feature); end

  # What is the path item that contains the dir as child?
  # e.g. given "/a/b/c/d" exists, and the path is ["/a/b"], load_dir("c/d")
  # is "/a/b".
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#22
  def load_dir(dir); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#110
  def push_paths(sender, *paths); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#115
  def reinitialize(path_obj = T.unsafe(nil)); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#105
  def unshift_paths(sender, *paths); end

  private

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#128
  def dir_changed?; end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#167
  def expand_path(feature); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#192
  def maybe_append_extension(f); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#175
  def now; end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#138
  def push_paths_locked(*paths); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#188
  def search_index(f); end

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#171
  def stale?; end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#203
  def try_ext(f); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#197
  def try_index(f); end

  # source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#153
  def unshift_paths_locked(*paths); end
end

# seconds
#
# source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#8
Bootsnap::LoadPathCache::Cache::AGE_THRESHOLD = T.let(T.unsafe(nil), Integer)

# { 'enumerator' => nil, 'enumerator.so' => nil, ... }
#
# source://bootsnap//lib/bootsnap/load_path_cache/cache.rb#28
Bootsnap::LoadPathCache::Cache::BUILTIN_FEATURES = T.let(T.unsafe(nil), Hash)

# source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#4
module Bootsnap::LoadPathCache::ChangeObserver
  class << self
    # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#56
    def register(observer, arr); end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#5
module Bootsnap::LoadPathCache::ChangeObserver::ArrayMixin
  # For each method that adds items to one end or another of the array
  # (<<, push, unshift, concat), override that method to also notify the
  # observer of the change.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#9
  def <<(entry); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def []=(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def clear(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def collect!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def compact!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#24
  def concat(entries); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def delete(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def delete_at(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def delete_if(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def fill(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def flatten!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def insert(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def keep_if(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def map!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def pop(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#14
  def push(*entries); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def reject!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def replace(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def reverse!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def rotate!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def select!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def shift(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def shuffle!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def slice!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def sort!(*args, &block); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#48
  def sort_by!(*args, &block); end

  # uniq! keeps the first occurrence of each path, otherwise preserving
  # order, preserving the effective load path
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#31
  def uniq!(*args); end

  # source://bootsnap//lib/bootsnap/load_path_cache/change_observer.rb#19
  def unshift(*entries); end
end

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#4
module Bootsnap::LoadPathCache::CoreExt
  class << self
    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#5
    def make_load_error(path); end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#5
module Bootsnap::LoadPathCache::CoreExt::ActiveSupport
  class << self
    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#14
    def allow_bootsnap_retry(allowed); end

    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#6
    def without_bootsnap_cache; end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#22
module Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#23
  def autoload_paths=(o); end

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#39
  def autoloadable_module?(path_suffix); end

  # Signature has changed a few times over the years; easiest to not
  # reiterate it with version polymorphism here...
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#85
  def depend_on(*_arg0); end

  # If we can't find a constant using the patched implementation of
  # search_for_file, try again with the default implementation.
  #
  # These methods call search_for_file, and we want to modify its
  # behaviour.  The gymnastics here are a bit awkward, but it prevents
  # 200+ lines of monkeypatches.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#59
  def load_missing_constant(from_mod, const_name); end

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#43
  def remove_constant(const); end

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#47
  def require_or_load(*_arg0); end

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/active_support.rb#28
  def search_for_file(path); end
end

# source://bootsnap//lib/bootsnap/load_path_cache.rb#22
Bootsnap::LoadPathCache::DLEXT = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache.rb#17
Bootsnap::LoadPathCache::DL_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://bootsnap//lib/bootsnap/load_path_cache.rb#8
Bootsnap::LoadPathCache::DOT_RB = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache.rb#9
Bootsnap::LoadPathCache::DOT_SO = T.let(T.unsafe(nil), String)

# If a NameError happens several levels deep, don't re-handle it
# all the way up the chain: mark it once and bubble it up without
# more retries.
#
# source://bootsnap//lib/bootsnap/load_path_cache.rb#15
Bootsnap::LoadPathCache::ERROR_TAG_IVAR = T.let(T.unsafe(nil), Symbol)

# source://bootsnap//lib/bootsnap/load_path_cache.rb#6
class Bootsnap::LoadPathCache::FallbackScan < ::StandardError; end

# LoadedFeaturesIndex partially mirrors an internal structure in ruby that
# we can't easily obtain an interface to.
#
# This works around an issue where, without bootsnap, *ruby* knows that it
# has already required a file by its short name (e.g. require 'bundler') if
# a new instance of bundler is added to the $LOAD_PATH which resolves to a
# different absolute path. This class makes bootsnap smart enough to
# realize that it has already loaded 'bundler', and not just
# '/path/to/bundler'.
#
# If you disable LoadedFeaturesIndex, you can see the problem this solves by:
#
# 1. `require 'a'`
# 2. Prepend a new $LOAD_PATH element containing an `a.rb`
# 3. `require 'a'`
#
# Ruby returns false from step 3.
# With bootsnap but with no LoadedFeaturesIndex, this loads two different
#   `a.rb`s.
# With bootsnap and with LoadedFeaturesIndex, this skips the second load,
#   returning false like ruby.
#
# source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#26
class Bootsnap::LoadPathCache::LoadedFeaturesIndex
  # @return [LoadedFeaturesIndex] a new instance of LoadedFeaturesIndex
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#27
  def initialize; end

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#67
  def key?(feature); end

  # We've optimized for initialize and register to be fast, and purge to be tolerable.
  # If access patterns make this not-okay, we can lazy-invert the LFI on
  # first purge and work from there.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#53
  def purge(feature); end

  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#60
  def purge_multi(features); end

  # There is a relatively uncommon case where we could miss adding an
  # entry:
  #
  # If the user asked for e.g. `require 'bundler'`, and we went through the
  # `FallbackScan` pathway in `kernel_require.rb` and therefore did not
  # pass `long` (the full expanded absolute path), then we did are not able
  # to confidently add the `bundler.rb` form to @lfi.
  #
  # We could either:
  #
  # 1. Just add `bundler.rb`, `bundler.so`, and so on, which is close but
  #    not quite right; or
  # 2. Inspect $LOADED_FEATURES upon return from yield to find the matching
  #    entry.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#85
  def register(short, long = T.unsafe(nil)); end

  private

  # Might Ruby automatically search for this extension if
  # someone tries to 'require' the file without it? E.g. Ruby
  # will implicitly try 'x.rb' if you ask for 'x'.
  #
  # This is complex and platform-dependent, and the Ruby docs are a little
  # handwavy about what will be tried when and in what order.
  # So optimistically pretend that all known elidable extensions
  # will be tried on all platforms, and that people are unlikely
  # to name files in a way that assumes otherwise.
  # (E.g. It's unlikely that someone will know that their code
  # will _never_ run on MacOS, and therefore think they can get away
  # with calling a Ruby file 'x.dylib.rb' and then requiring it as 'x.dylib'.)
  #
  # See <https://ruby-doc.org/core-2.6.4/Kernel.html#method-i-require>.
  #
  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#135
  def extension_elidable?(f); end

  # source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#139
  def strip_extension_if_elidable(f); end
end

# source://bootsnap//lib/bootsnap/load_path_cache/loaded_features_index.rb#118
Bootsnap::LoadPathCache::LoadedFeaturesIndex::STRIP_EXTENSION = T.let(T.unsafe(nil), Regexp)

# source://bootsnap//lib/bootsnap/load_path_cache/path.rb#6
class Bootsnap::LoadPathCache::Path
  # @return [Path] a new instance of Path
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#23
  def initialize(path); end

  # Return a list of all the requirable files and all of the subdirectories
  # of this +Path+.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#40
  def entries_and_dirs(store); end

  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#62
  def expanded_path; end

  # True if the path exists, but represents a non-directory object
  #
  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#28
  def non_directory?; end

  # Returns the value of attribute path.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#21
  def path; end

  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#34
  def relative?; end

  # A path is considered 'stable' if it is part of a Gem.path or the ruby
  # distribution. When adding or removing files in these paths, the cache
  # must be cleared before the change will be noticed.
  #
  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#10
  def stable?; end

  # A path is considered volatile if it doesn't live under a Gem.path or
  # the ruby distribution root. These paths are scanned for new additions
  # more frequently.
  #
  # @return [Boolean]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#17
  def volatile?; end

  private

  # last time a directory was modified in this subtree. +dirs+ should be a
  # list of relative paths to directories under +path+. e.g. for /a/b and
  # /a/b/c, pass ('/a/b', ['c'])
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#75
  def latest_mtime(path, dirs); end

  # (expensive) returns [entries, dirs]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#68
  def scan!; end

  # source://bootsnap//lib/bootsnap/load_path_cache/path.rb#99
  def stability; end
end

# Built-in ruby lib stuff doesn't change, but things can occasionally be
# installed into sitedir, which generally lives under libdir.
#
# source://bootsnap//lib/bootsnap/load_path_cache/path.rb#96
Bootsnap::LoadPathCache::Path::RUBY_LIBDIR = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache/path.rb#97
Bootsnap::LoadPathCache::Path::RUBY_SITEDIR = T.let(T.unsafe(nil), String)

# a Path can be either stable of volatile, depending on how frequently we
# expect its contents may change. Stable paths aren't rescanned nearly as
# often.
#
# source://bootsnap//lib/bootsnap/load_path_cache/path.rb#91
Bootsnap::LoadPathCache::Path::STABLE = T.let(T.unsafe(nil), Symbol)

# source://bootsnap//lib/bootsnap/load_path_cache/path.rb#92
Bootsnap::LoadPathCache::Path::VOLATILE = T.let(T.unsafe(nil), Symbol)

# source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#7
module Bootsnap::LoadPathCache::PathScanner
  class << self
    # source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#19
    def call(path); end

    # source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#45
    def walk(absolute_dir_path, relative_dir_path, &block); end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#10
Bootsnap::LoadPathCache::PathScanner::ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#12
Bootsnap::LoadPathCache::PathScanner::BUNDLE_PATH = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#9
Bootsnap::LoadPathCache::PathScanner::NORMALIZE_NATIVE_EXTENSIONS = T.let(T.unsafe(nil), TrueClass)

# source://bootsnap//lib/bootsnap/load_path_cache/path_scanner.rb#8
Bootsnap::LoadPathCache::PathScanner::REQUIRABLE_EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://bootsnap//lib/bootsnap/load_path_cache/realpath_cache.rb#5
class Bootsnap::LoadPathCache::RealpathCache
  # @return [RealpathCache] a new instance of RealpathCache
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/realpath_cache.rb#6
  def initialize; end

  # source://bootsnap//lib/bootsnap/load_path_cache/realpath_cache.rb#10
  def call(*key); end

  private

  # source://bootsnap//lib/bootsnap/load_path_cache/realpath_cache.rb#22
  def find_file(name); end

  # source://bootsnap//lib/bootsnap/load_path_cache/realpath_cache.rb#16
  def realpath(caller_location, path); end
end

# source://bootsnap//lib/bootsnap/load_path_cache.rb#5
class Bootsnap::LoadPathCache::ReturnFalse < ::StandardError; end

# source://bootsnap//lib/bootsnap/load_path_cache.rb#10
Bootsnap::LoadPathCache::SLASH = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache/store.rb#9
class Bootsnap::LoadPathCache::Store
  # @return [Store] a new instance of Store
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#13
  def initialize(store_path); end

  # @raise [SetOutsideTransactionNotAllowed]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#25
  def fetch(key); end

  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#21
  def get(key); end

  # @raise [SetOutsideTransactionNotAllowed]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#36
  def set(key, value); end

  # @raise [NestedTransactionError]
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#44
  def transaction; end

  private

  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#57
  def commit_transaction; end

  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#75
  def dump_data; end

  # source://bootsnap//lib/bootsnap/load_path_cache/store.rb#64
  def load_data; end
end

# source://bootsnap//lib/bootsnap/load_path_cache/store.rb#10
class Bootsnap::LoadPathCache::Store::NestedTransactionError < ::StandardError; end

# source://bootsnap//lib/bootsnap/load_path_cache/store.rb#11
class Bootsnap::LoadPathCache::Store::SetOutsideTransactionNotAllowed < ::StandardError; end

# source://bootsnap//lib/bootsnap/version.rb#3
Bootsnap::VERSION = T.let(T.unsafe(nil), String)

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#15
module Kernel
  private

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#57
  def load(path, wrap = T.unsafe(nil)); end

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#27
  def require(path); end

  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#49
  def require_relative(path); end

  # Note that require registers to $LOADED_FEATURES while load does not.
  #
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#21
  def require_with_bootsnap_lfi(path, resolved = T.unsafe(nil)); end

  class << self
    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#57
    def load(path, wrap = T.unsafe(nil)); end

    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#27
    def require(path); end

    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#49
    def require_relative(path); end

    # Note that require registers to $LOADED_FEATURES while load does not.
    #
    # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#21
    def require_with_bootsnap_lfi(path, resolved = T.unsafe(nil)); end
  end
end

# source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#82
class Module
  # source://bootsnap//lib/bootsnap/load_path_cache/core_ext/kernel_require.rb#84
  def autoload(const, path); end
end

# source://activesupport/6.0.0/lib/active_support/core_ext/module/delegation.rb#13
Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://activesupport/6.0.0/lib/active_support/core_ext/module/delegation.rb#14
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://activesupport/6.0.0/lib/active_support/core_ext/module/delegation.rb#10
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

module Psych
  extend ::Bootsnap::CompileCache::YAML::Patch
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
end
