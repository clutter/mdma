# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `parlour` gem.
# Please instead update this file by running `bin/tapioca gem parlour`.

# source://parlour//lib/parlour/version.rb#2
module Parlour; end

# Responsible for resolving conflicts (that is, multiple definitions with the
# same name) between objects defined in the same namespace.
#
# source://parlour//lib/parlour/conflict_resolver.rb#5
class Parlour::ConflictResolver
  # source://parlour//lib/parlour/conflict_resolver.rb#41
  sig do
    params(
      namespace: ::Parlour::RbiGenerator::Namespace,
      resolver: T.proc.params(desc: ::String, choices: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(::Parlour::RbiGenerator::RbiObject)
    ).void
  end
  def resolve_conflicts(namespace, &resolver); end

  private

  # source://parlour//lib/parlour/conflict_resolver.rb#213
  sig { params(arr: T::Array[T.untyped]).returns(T::Boolean) }
  def all_eql?(arr); end

  # source://parlour//lib/parlour/conflict_resolver.rb#178
  sig { params(arr: T::Array[T.untyped]).returns(T.nilable(::Symbol)) }
  def merge_strategy(arr); end
end

# Contains methods to enable debugging facilities for Parlour.
#
# source://parlour//lib/parlour/debugging.rb#6
module Parlour::Debugging
  class << self
    # Set whether debug messages should be printed.
    #
    # source://parlour//lib/parlour/debugging.rb#16
    sig { params(value: T::Boolean).returns(T::Boolean) }
    def debug_mode=(value); end

    # Whether debug messages sent by {#debug_puts} should be printed.
    # Defaults to true if the PARLOUR_DEBUG environment variable is set.
    #
    # source://parlour//lib/parlour/debugging.rb#24
    sig { returns(T::Boolean) }
    def debug_mode?; end

    # Prints a message with a debugging prefix to STDOUT if {#debug_mode?} is
    # true.
    #
    # source://parlour//lib/parlour/debugging.rb#36
    sig { params(object: T.untyped, message: ::String).void }
    def debug_puts(object, message); end

    # Converts the given object into a human-readable prefix to a debug message.
    # For example, passing an instance of {ConflictResolver} returns
    # "conflict resolver". If the object type is unknown, this returns its class
    # name.
    #
    # source://parlour//lib/parlour/debugging.rb#50
    sig { params(object: T.untyped).returns(::String) }
    def name_for_debug_caller(object); end
  end
end

# A module for generating a globally-consistent, nicely-formatted tree of
# output using Unicode block characters.
#
# source://parlour//lib/parlour/debugging.rb#66
module Parlour::Debugging::Tree
  class << self
    # Returns a new heading, and then decents the tree one level into it.
    # (That is, future output will go under the new heading.)
    #
    # source://parlour//lib/parlour/debugging.rb#81
    sig { params(message: ::String).returns(::String) }
    def begin(message); end

    # Prints the final tree element at the current level, then ascends one
    # level.
    #
    # source://parlour//lib/parlour/debugging.rb#100
    sig { params(message: ::String).returns(::String) }
    def end(message); end

    # Prints a new tree element at the current level.
    #
    # source://parlour//lib/parlour/debugging.rb#91
    sig { params(message: ::String).returns(::String) }
    def here(message); end

    # The prefix which should be printed before anything else on this line of
    # the tree, based on the current indent level.
    #
    # @return [String]
    #
    # source://parlour//lib/parlour/debugging.rb#109
    def line_prefix; end

    # The horizontal lines which should be printed between the beginning of
    # the current element and its text, based on the specified number of
    # spaces to use for indents.
    #
    # @return [String]
    #
    # source://parlour//lib/parlour/debugging.rb#117
    def text_prefix; end
  end
end

# The number of spaces to indent each layer of the tree by. Should be at
# least 1.
#
# source://parlour//lib/parlour/debugging.rb#71
Parlour::Debugging::Tree::INDENT_SPACES = T.let(T.unsafe(nil), Integer)

# source://parlour//lib/parlour/detached_rbi_generator.rb#4
class Parlour::DetachedRbiGenerator < ::Parlour::RbiGenerator
  # source://parlour//lib/parlour/detached_rbi_generator.rb#21
  sig { override.returns(T.nilable(::Parlour::Plugin)) }
  def current_plugin; end

  # source://parlour//lib/parlour/detached_rbi_generator.rb#6
  sig { returns(T.untyped) }
  def detached!; end

  # source://parlour//lib/parlour/detached_rbi_generator.rb#11
  sig { override.returns(::Parlour::RbiGenerator::Options) }
  def options; end

  # source://parlour//lib/parlour/detached_rbi_generator.rb#26
  sig { override.params(strictness: ::String).returns(::String) }
  def rbi(strictness = T.unsafe(nil)); end

  # source://parlour//lib/parlour/detached_rbi_generator.rb#16
  sig { override.returns(::Parlour::RbiGenerator::Namespace) }
  def root; end
end

# source://parlour//lib/parlour/parse_error.rb#4
class Parlour::ParseError < ::StandardError
  # @return [ParseError] a new instance of ParseError
  #
  # source://parlour//lib/parlour/parse_error.rb#13
  def initialize(buffer, range); end

  # source://parlour//lib/parlour/parse_error.rb#8
  sig { returns(::Parser::Source::Buffer) }
  def buffer; end

  # source://parlour//lib/parlour/parse_error.rb#11
  sig { returns(::Parser::Source::Range) }
  def range; end
end

# The base class for user-defined RBI generation plugins.
#
# @abstract
#
# source://parlour//lib/parlour/plugin.rb#5
class Parlour::Plugin
  abstract!

  # source://parlour//lib/parlour/plugin.rb#54
  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options); end

  # @abstract
  #
  # source://parlour//lib/parlour/plugin.rb#63
  sig { abstract.params(root: ::Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  # source://parlour//lib/parlour/plugin.rb#70
  sig { returns(T.nilable(::String)) }
  def strictness; end

  # @return [String, nil]
  #
  # source://parlour//lib/parlour/plugin.rb#70
  def strictness=(_arg0); end

  class << self
    # source://parlour//lib/parlour/plugin.rb#27
    sig { params(new_plugin: T.class_of(Parlour::Plugin)).void }
    def inherited(new_plugin); end

    # source://parlour//lib/parlour/plugin.rb#17
    sig { returns(T::Hash[::String, T.class_of(Parlour::Plugin)]) }
    def registered_plugins; end

    # source://parlour//lib/parlour/plugin.rb#40
    sig do
      params(
        plugins: T::Array[::Parlour::Plugin],
        generator: ::Parlour::RbiGenerator,
        allow_failure: T::Boolean
      ).void
    end
    def run_plugins(plugins, generator, allow_failure: T.unsafe(nil)); end
  end
end

# The RBI generator.
#
# source://parlour//lib/parlour/rbi_generator/parameter.rb#3
class Parlour::RbiGenerator
  # source://parlour//lib/parlour/rbi_generator.rb#22
  sig { params(break_params: ::Integer, tab_size: ::Integer, sort_namespaces: T::Boolean).void }
  def initialize(break_params: T.unsafe(nil), tab_size: T.unsafe(nil), sort_namespaces: T.unsafe(nil)); end

  # source://parlour//lib/parlour/rbi_generator.rb#45
  sig { overridable.returns(T.nilable(::Parlour::Plugin)) }
  def current_plugin; end

  # @return [Plugin, nil]
  #
  # source://parlour//lib/parlour/rbi_generator.rb#45
  def current_plugin=(_arg0); end

  # source://parlour//lib/parlour/rbi_generator.rb#34
  sig { overridable.returns(::Parlour::RbiGenerator::Options) }
  def options; end

  # source://parlour//lib/parlour/rbi_generator.rb#51
  sig { overridable.params(strictness: ::String).returns(::String) }
  def rbi(strictness = T.unsafe(nil)); end

  # source://parlour//lib/parlour/rbi_generator.rb#39
  sig { overridable.returns(::Parlour::RbiGenerator::Namespace) }
  def root; end
end

# Represents miscellaneous Ruby code.
#
# source://parlour//lib/parlour/rbi_generator/arbitrary.rb#5
class Parlour::RbiGenerator::Arbitrary < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#17
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      code: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Arbitrary).void)
    ).void
  end
  def initialize(generator, code: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#33
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#25
  sig { returns(::String) }
  def code; end

  # @return [String]
  #
  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#25
  def code=(_arg0); end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#87
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#48
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#79
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/arbitrary.rb#63
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

# Represents an attribute reader, writer or accessor.
#
# source://parlour//lib/parlour/rbi_generator/attribute.rb#5
class Parlour::RbiGenerator::Attribute < ::Parlour::RbiGenerator::Method
  # source://parlour//lib/parlour/rbi_generator/attribute.rb#29
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      kind: ::Symbol,
      type: ::String,
      class_attribute: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Attribute).void)
    ).void
  end
  def initialize(generator, name, kind, type, class_attribute: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/attribute.rb#64
  sig { override.params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/attribute.rb#56
  sig { returns(T::Boolean) }
  def class_attribute; end

  # source://parlour//lib/parlour/rbi_generator/attribute.rb#52
  sig { returns(::Symbol) }
  def kind; end

  private

  # source://parlour//lib/parlour/rbi_generator/attribute.rb#85
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_definition(indent_level, options); end
end

# Represents a class definition.
#
# source://parlour//lib/parlour/rbi_generator/class_namespace.rb#5
class Parlour::RbiGenerator::ClassNamespace < ::Parlour::RbiGenerator::Namespace
  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#29
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      final: T::Boolean,
      superclass: T.nilable(::String),
      abstract: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::ClassNamespace).void)
    ).void
  end
  def initialize(generator, name, final, superclass, abstract, &block); end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#66
  sig { returns(T::Boolean) }
  def abstract; end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#114
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#46
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#100
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#80
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  # source://parlour//lib/parlour/rbi_generator/class_namespace.rb#61
  sig { returns(T.nilable(::String)) }
  def superclass; end
end

# Represents a constant definition.
#
# source://parlour//lib/parlour/rbi_generator/constant.rb#5
class Parlour::RbiGenerator::Constant < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/constant.rb#18
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      value: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Constant).void)
    ).void
  end
  def initialize(generator, name: T.unsafe(nil), value: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#34
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#89
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#49
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#81
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#64
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  # source://parlour//lib/parlour/rbi_generator/constant.rb#26
  sig { returns(::String) }
  def value; end
end

# Represents an enum definition; that is, a class with an +enum+ call.
#
# source://parlour//lib/parlour/rbi_generator/enum_class_namespace.rb#5
class Parlour::RbiGenerator::EnumClassNamespace < ::Parlour::RbiGenerator::ClassNamespace
  # source://parlour//lib/parlour/rbi_generator/enum_class_namespace.rb#28
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      final: T::Boolean,
      enums: T::Array[T.any(::String, [::String, ::String])],
      abstract: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::EnumClassNamespace).void)
    ).void
  end
  def initialize(generator, name, final, enums, abstract, &block); end

  # source://parlour//lib/parlour/rbi_generator/enum_class_namespace.rb#36
  sig { returns(T::Array[T.any(::String, [::String, ::String])]) }
  def enums; end

  # source://parlour//lib/parlour/rbi_generator/enum_class_namespace.rb#50
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_body(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/enum_class_namespace.rb#82
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

# Represents an +extend+ call.
#
# source://parlour//lib/parlour/rbi_generator/extend.rb#5
class Parlour::RbiGenerator::Extend < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/extend.rb#16
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Extend).void)
    ).void
  end
  def initialize(generator, name: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/extend.rb#27
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/extend.rb#82
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/extend.rb#42
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/extend.rb#74
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/extend.rb#57
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

# Represents an +include+ call.
#
# source://parlour//lib/parlour/rbi_generator/include.rb#5
class Parlour::RbiGenerator::Include < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/include.rb#16
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Include).void)
    ).void
  end
  def initialize(generator, name: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/include.rb#27
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/include.rb#82
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/include.rb#42
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/include.rb#74
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/include.rb#57
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

# Represents a method definition.
#
# source://parlour//lib/parlour/rbi_generator/method.rb#5
class Parlour::RbiGenerator::Method < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/method.rb#46
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      parameters: T::Array[::Parlour::RbiGenerator::Parameter],
      return_type: T.nilable(::String),
      abstract: T::Boolean,
      implementation: T::Boolean,
      override: T::Boolean,
      overridable: T::Boolean,
      class_method: T::Boolean,
      final: T::Boolean,
      type_parameters: T.nilable(T::Array[::Symbol]),
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Method).void)
    ).void
  end
  def initialize(generator, name, parameters, return_type = T.unsafe(nil), abstract: T.unsafe(nil), implementation: T.unsafe(nil), override: T.unsafe(nil), overridable: T.unsafe(nil), class_method: T.unsafe(nil), final: T.unsafe(nil), type_parameters: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#66
  sig { overridable.params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#94
  sig { returns(T::Boolean) }
  def abstract; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#119
  sig { returns(T::Boolean) }
  def class_method; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#215
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#124
  sig { returns(T::Boolean) }
  def final; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#142
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#102
  sig { returns(T::Boolean) }
  def implementation; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#207
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#190
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#113
  sig { returns(T::Boolean) }
  def overridable; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#108
  sig { returns(T::Boolean) }
  def override; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#83
  sig { returns(T::Array[::Parlour::RbiGenerator::Parameter]) }
  def parameters; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#89
  sig { returns(T.nilable(::String)) }
  def return_type; end

  # source://parlour//lib/parlour/rbi_generator/method.rb#129
  sig { returns(T::Array[::Symbol]) }
  def type_parameters; end

  private

  # source://parlour//lib/parlour/rbi_generator/method.rb#234
  sig do
    overridable
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_definition(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/method.rb#251
  sig { returns(::String) }
  def qualifiers; end
end

# Represents a module definition.
#
# source://parlour//lib/parlour/rbi_generator/module_namespace.rb#5
class Parlour::RbiGenerator::ModuleNamespace < ::Parlour::RbiGenerator::Namespace
  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#27
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: ::String,
      final: T::Boolean,
      interface: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::ClassNamespace).void)
    ).void
  end
  def initialize(generator, name, final, interface, &block); end

  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#95
  sig { override.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#44
  sig do
    override
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#55
  sig { returns(T::Boolean) }
  def interface; end

  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#88
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/module_namespace.rb#69
  sig { override.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

# A generic namespace. This shouldn't be used, except as the type of
# {RbiGenerator#root}.
#
# source://parlour//lib/parlour/rbi_generator/namespace.rb#6
class Parlour::RbiGenerator::Namespace < ::Parlour::RbiGenerator::RbiObject
  # source://parlour//lib/parlour/rbi_generator/namespace.rb#42
  sig do
    params(
      generator: ::Parlour::RbiGenerator,
      name: T.nilable(::String),
      final: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Namespace).void)
    ).void
  end
  def initialize(generator, name = T.unsafe(nil), final = T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#131
  sig { params(comment: T.any(::String, T::Array[::String])).void }
  def add_comment_to_next_child(comment); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#58
  sig { returns(T::Array[::Parlour::RbiGenerator::RbiObject]) }
  def children; end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#83
  sig { returns(T::Array[::Parlour::RbiGenerator::Constant]) }
  def constants; end

  # Creates a new arbitrary code section.
  # You should rarely have to use this!
  #
  # @param code [String] The code to insert.
  # @param block A block which the new instance yields itself to.
  # @return [RbiGenerator::Arbitrary]
  #
  # source://parlour//lib/parlour/rbi_generator/namespace.rb#416
  def create_arbitrary(code:, &block); end

  # @param name [String]
  # @param kind [Symbol]
  # @param type [String]
  # @param class_attribute [Boolean]
  # @param block [T.proc.params(x: Attribute).void, nil]
  # @return [Attribute]
  #
  # source://sorbet-runtime/0.5.10448/lib/types/private/methods/_methods.rb#250
  def create_attr(*args, &blk); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#406
  sig do
    params(
      name: ::String,
      type: ::String,
      class_attribute: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Attribute).void)
    ).returns(::Parlour::RbiGenerator::Attribute)
  end
  def create_attr_accessor(name, type:, class_attribute: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#364
  sig do
    params(
      name: ::String,
      type: ::String,
      class_attribute: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Attribute).void)
    ).returns(::Parlour::RbiGenerator::Attribute)
  end
  def create_attr_reader(name, type:, class_attribute: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#385
  sig do
    params(
      name: ::String,
      type: ::String,
      class_attribute: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Attribute).void)
    ).returns(::Parlour::RbiGenerator::Attribute)
  end
  def create_attr_writer(name, type:, class_attribute: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#332
  sig do
    params(
      name: ::String,
      kind: ::Symbol,
      type: ::String,
      class_attribute: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Attribute).void)
    ).returns(::Parlour::RbiGenerator::Attribute)
  end
  def create_attribute(name, kind:, type:, class_attribute: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#165
  sig do
    params(
      name: ::String,
      final: T::Boolean,
      superclass: T.nilable(::String),
      abstract: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::ClassNamespace).void)
    ).returns(::Parlour::RbiGenerator::ClassNamespace)
  end
  def create_class(name, final: T.unsafe(nil), superclass: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#511
  sig do
    params(
      name: ::String,
      value: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Constant).void)
    ).returns(::Parlour::RbiGenerator::Constant)
  end
  def create_constant(name, value:, &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#192
  sig do
    params(
      name: ::String,
      final: T::Boolean,
      enums: T.nilable(T::Array[T.any(::String, [::String, ::String])]),
      abstract: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::EnumClassNamespace).void)
    ).returns(::Parlour::RbiGenerator::EnumClassNamespace)
  end
  def create_enum_class(name, final: T.unsafe(nil), enums: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#437
  sig do
    params(
      name: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Extend).void)
    ).returns(::Parlour::RbiGenerator::Extend)
  end
  def create_extend(name, &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#456
  sig { params(extendables: T::Array[::String]).returns(T::Array[::Parlour::RbiGenerator::Extend]) }
  def create_extends(extendables); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#474
  sig do
    params(
      name: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Include).void)
    ).returns(::Parlour::RbiGenerator::Include)
  end
  def create_include(name, &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#493
  sig { params(includables: T::Array[::String]).returns(T::Array[::Parlour::RbiGenerator::Include]) }
  def create_includes(includables); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#267
  sig do
    params(
      name: ::String,
      parameters: T.nilable(T::Array[::Parlour::RbiGenerator::Parameter]),
      return_type: T.nilable(::String),
      returns: T.nilable(::String),
      abstract: T::Boolean,
      implementation: T::Boolean,
      override: T::Boolean,
      overridable: T::Boolean,
      class_method: T::Boolean,
      final: T::Boolean,
      type_parameters: T.nilable(T::Array[::Symbol]),
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Method).void)
    ).returns(::Parlour::RbiGenerator::Method)
  end
  def create_method(name, parameters: T.unsafe(nil), return_type: T.unsafe(nil), returns: T.unsafe(nil), abstract: T.unsafe(nil), implementation: T.unsafe(nil), override: T.unsafe(nil), overridable: T.unsafe(nil), class_method: T.unsafe(nil), final: T.unsafe(nil), type_parameters: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#223
  sig do
    params(
      name: ::String,
      final: T::Boolean,
      interface: T::Boolean,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::ClassNamespace).void)
    ).returns(::Parlour::RbiGenerator::ModuleNamespace)
  end
  def create_module(name, final: T.unsafe(nil), interface: T.unsafe(nil), &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#533
  sig do
    params(
      name: ::String,
      type: ::String,
      block: T.nilable(T.proc.params(x: ::Parlour::RbiGenerator::Constant).void)
    ).returns(::Parlour::RbiGenerator::Constant)
  end
  def create_type_alias(name, type:, &block); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#581
  sig { override.overridable.returns(::String) }
  def describe; end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#63
  sig { returns(T::Array[::Parlour::RbiGenerator::Extend]) }
  def extends; end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#53
  sig { returns(T::Boolean) }
  def final; end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#20
  sig do
    override
      .overridable
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#73
  sig { returns(T::Array[::Parlour::RbiGenerator::Include]) }
  def includes; end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#568
  sig { override.overridable.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#550
  sig { override.overridable.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#96
  sig { params(object: T.untyped, block: T.proc.params(x: ::Parlour::RbiGenerator::Namespace).void).void }
  def path(object, &block); end

  private

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#600
  sig do
    overridable
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_body(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/namespace.rb#667
  sig { params(object: ::Parlour::RbiGenerator::RbiObject).void }
  def move_next_comments(object); end
end

# A set of immutable formatting options passed to all calls of
# {RbiObject#generate_rbi}.
#
# source://parlour//lib/parlour/rbi_generator/options.rb#6
class Parlour::RbiGenerator::Options
  # source://parlour//lib/parlour/rbi_generator/options.rb#21
  sig { params(break_params: ::Integer, tab_size: ::Integer, sort_namespaces: T::Boolean).void }
  def initialize(break_params:, tab_size:, sort_namespaces:); end

  # source://parlour//lib/parlour/rbi_generator/options.rb#45
  sig { returns(::Integer) }
  def break_params; end

  # source://parlour//lib/parlour/rbi_generator/options.rb#69
  sig { params(level: ::Integer, str: ::String).returns(::String) }
  def indented(level, str); end

  # source://parlour//lib/parlour/rbi_generator/options.rb#60
  sig { returns(T::Boolean) }
  def sort_namespaces; end

  # source://parlour//lib/parlour/rbi_generator/options.rb#50
  sig { returns(::Integer) }
  def tab_size; end
end

# Represents a method parameter with a Sorbet type signature.
#
# source://parlour//lib/parlour/rbi_generator/parameter.rb#5
class Parlour::RbiGenerator::Parameter
  # source://parlour//lib/parlour/rbi_generator/parameter.rb#36
  sig { params(name: ::String, type: T.nilable(::String), default: T.nilable(::String)).void }
  def initialize(name, type: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#55
  sig { params(other: ::Object).returns(T::Boolean) }
  def ==(other); end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#94
  sig { returns(T.nilable(::String)) }
  def default; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#100
  sig { returns(::Symbol) }
  def kind; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#67
  sig { returns(::String) }
  def name; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#74
  sig { returns(::String) }
  def name_without_kind; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#106
  sig { returns(::String) }
  def to_def_param; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#120
  sig { returns(::String) }
  def to_sig_param; end

  # source://parlour//lib/parlour/rbi_generator/parameter.rb#87
  sig { returns(T.nilable(::String)) }
  def type; end
end

# A mapping of {kind} values to the characteristic prefixes each kind has.
#
# source://parlour//lib/parlour/rbi_generator/parameter.rb#125
Parlour::RbiGenerator::Parameter::PREFIXES = T.let(T.unsafe(nil), Hash)

# An abstract class which is subclassed by any classes which can generate
# entire lines of an RBI, such as {Namespace} and {Method}. (As an example,
# {Parameter} is _not_ a subclass because it does not generate lines, only
# segments of definition and signature lines.)
#
# @abstract
#
# source://parlour//lib/parlour/rbi_generator/rbi_object.rb#9
class Parlour::RbiGenerator::RbiObject
  abstract!

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#21
  sig { params(generator: ::Parlour::RbiGenerator, name: ::String).void }
  def initialize(generator, name); end

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#66
  sig { params(comment: T.any(::String, T::Array[::String])).void }
  def add_comment(comment); end

  # @param comment [String, Array<String>]
  # @return [void]
  #
  # source://sorbet-runtime/0.5.10448/lib/types/private/methods/_methods.rb#250
  def add_comments(*args, &blk); end

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#48
  sig { returns(T::Array[::String]) }
  def comments; end

  # @abstract
  #
  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#124
  sig { abstract.returns(::String) }
  def describe; end

  # @abstract
  #
  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#88
  sig do
    abstract
      .params(
        indent_level: ::Integer,
        options: ::Parlour::RbiGenerator::Options
      ).returns(T::Array[::String])
  end
  def generate_rbi(indent_level, options); end

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#37
  sig { returns(T.nilable(::Parlour::Plugin)) }
  def generated_by; end

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#31
  sig { returns(::Parlour::RbiGenerator) }
  def generator; end

  # @abstract
  #
  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#116
  sig { abstract.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  # @abstract
  #
  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#102
  sig { abstract.params(others: T::Array[::Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#42
  sig { returns(::String) }
  def name; end

  private

  # source://parlour//lib/parlour/rbi_generator/rbi_object.rb#139
  sig { params(indent_level: ::Integer, options: ::Parlour::RbiGenerator::Options).returns(T::Array[::String]) }
  def generate_comments(indent_level, options); end
end

# source://parlour//lib/parlour/type_loader.rb#7
module Parlour::TypeLoader
  class << self
    # source://parlour//lib/parlour/type_loader.rb#29
    sig { params(filename: ::String).returns(::Parlour::RbiGenerator::Namespace) }
    def load_file(filename); end

    # source://parlour//lib/parlour/type_loader.rb#45
    sig { params(root: ::String, exclusions: T::Array[::String]).returns(::Parlour::RbiGenerator::Namespace) }
    def load_project(root, exclusions: T.unsafe(nil)); end

    # TODO: make this into a class which stores configuration and passes it to
    # all typeparsers
    #
    # source://parlour//lib/parlour/type_loader.rb#20
    sig { params(source: ::String, filename: T.nilable(::String)).returns(::Parlour::RbiGenerator::Namespace) }
    def load_source(source, filename = T.unsafe(nil)); end
  end
end

# Parses Ruby source to find Sorbet type signatures.
#
# source://parlour//lib/parlour/type_parser.rb#17
class Parlour::TypeParser
  # source://parlour//lib/parlour/type_parser.rb#95
  sig { params(ast: ::Parser::AST::Node, unknown_node_errors: T::Boolean).void }
  def initialize(ast, unknown_node_errors: T.unsafe(nil)); end

  # source://parlour//lib/parlour/type_parser.rb#116
  sig { returns(::Parser::AST::Node) }
  def ast; end

  # @return [Parser::AST::Node]
  #
  # source://parlour//lib/parlour/type_parser.rb#116
  def ast=(_arg0); end

  # Parses the entire source file and returns the resulting root namespace.
  #
  # source://parlour//lib/parlour/type_parser.rb#127
  sig { returns(::Parlour::RbiGenerator::Namespace) }
  def parse_all; end

  # Given a path to a node in the AST, parses the object definitions it
  # represents and returns it, recursing to any child namespaces and parsing
  # any methods within.
  #
  # If the node directly represents several nodes, such as being a
  # (begin ...) node, they are all returned.
  #
  # source://parlour//lib/parlour/type_parser.rb#145
  sig do
    params(
      path: ::Parlour::TypeParser::NodePath,
      is_within_eigenclass: T::Boolean
    ).returns(T::Array[::Parlour::RbiGenerator::RbiObject])
  end
  def parse_path_to_object(path, is_within_eigenclass: T.unsafe(nil)); end

  # source://parlour//lib/parlour/type_parser.rb#358
  sig do
    params(
      path: ::Parlour::TypeParser::NodePath,
      is_within_eigenclass: T::Boolean
    ).returns(T::Array[::Parlour::RbiGenerator::Method])
  end
  def parse_sig_into_methods(path, is_within_eigenclass: T.unsafe(nil)); end

  # source://parlour//lib/parlour/type_parser.rb#280
  sig { params(path: ::Parlour::TypeParser::NodePath).returns(::Parlour::TypeParser::IntermediateSig) }
  def parse_sig_into_sig(path); end

  # source://parlour//lib/parlour/type_parser.rb#121
  sig { returns(T::Boolean) }
  def unknown_node_errors; end

  protected

  # source://parlour//lib/parlour/type_parser.rb#545
  sig { params(node: T.nilable(::Parser::AST::Node), modifier: ::Symbol).returns(T::Boolean) }
  def body_has_modifier?(node, modifier); end

  # source://parlour//lib/parlour/type_parser.rb#560
  sig { params(node: ::Parser::AST::Node).returns([T::Array[::String], T::Array[::String]]) }
  def body_includes_and_extends(node); end

  # source://parlour//lib/parlour/type_parser.rb#503
  sig { params(node: T.nilable(::Parser::AST::Node)).returns(T::Array[::Symbol]) }
  def constant_names(node); end

  # source://parlour//lib/parlour/type_parser.rb#527
  sig { params(node: T.nilable(::Parser::AST::Node)).returns(T.nilable(::String)) }
  def node_to_s(node); end

  # @raise [ParseError.new(buffer, range)]
  #
  # source://parlour//lib/parlour/type_parser.rb#584
  sig { params(desc: ::String, node: T.any(::Parlour::TypeParser::NodePath, ::Parser::AST::Node)).returns(T.noreturn) }
  def parse_err(desc, node); end

  # source://parlour//lib/parlour/type_parser.rb#515
  sig { params(node: ::Parser::AST::Node).returns(T::Boolean) }
  def sig_node?(node); end

  # @raise [ArgumentError]
  #
  # source://parlour//lib/parlour/type_parser.rb#617
  sig do
    type_parameters(:A, :B)
      .params(
        a: T::Array[T.type_parameter(:A)],
        fa: T.proc.params(item: T.type_parameter(:A)).returns(T.untyped),
        b: T::Array[T.type_parameter(:B)],
        fb: T.proc.params(item: T.type_parameter(:B)).returns(T.untyped)
      ).returns(T::Array[[T.type_parameter(:A), T.type_parameter(:B)]])
  end
  def zip_by(a, fa, b, fb); end

  class << self
    # source://parlour//lib/parlour/type_parser.rb#107
    sig { params(filename: ::String, source: ::String).returns(::Parlour::TypeParser) }
    def from_source(filename, source); end
  end
end

# A parsed sig, not associated with a method.
#
# source://parlour//lib/parlour/type_parser.rb#261
class Parlour::TypeParser::IntermediateSig < ::T::Struct
  prop :abstract, T::Boolean
  prop :final, T::Boolean
  prop :overridable, T::Boolean
  prop :override, T::Boolean
  prop :params, T.nilable(T::Array[::Parser::AST::Node])
  prop :return_type, T.nilable(::String)
  prop :type_parameters, T.nilable(T::Array[::Symbol])

  class << self
    # source://sorbet-runtime/0.5.10448/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# Represents a path of indices which can be traversed to reach a specific
# node in an AST.
#
# source://parlour//lib/parlour/type_parser.rb#20
class Parlour::TypeParser::NodePath
  # source://parlour//lib/parlour/type_parser.rb#31
  sig { params(indices: T::Array[::Integer]).void }
  def initialize(indices); end

  # source://parlour//lib/parlour/type_parser.rb#48
  sig { params(index: ::Integer).returns(::Parlour::TypeParser::NodePath) }
  def child(index); end

  # source://parlour//lib/parlour/type_parser.rb#25
  sig { returns(T::Array[::Integer]) }
  def indices; end

  # source://parlour//lib/parlour/type_parser.rb#37
  sig { returns(::Parlour::TypeParser::NodePath) }
  def parent; end

  # source://parlour//lib/parlour/type_parser.rb#57
  sig { params(offset: ::Integer).returns(::Parlour::TypeParser::NodePath) }
  def sibling(offset); end

  # source://parlour//lib/parlour/type_parser.rb#74
  sig { params(start: ::Parser::AST::Node).returns(::Parser::AST::Node) }
  def traverse(start); end
end

# The library version.
#
# source://parlour//lib/parlour/version.rb#4
Parlour::VERSION = T.let(T.unsafe(nil), String)
