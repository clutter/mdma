# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json` gem.
# Please instead update this file by running `bin/tapioca gem json`.

# Extends any Class to include _json_creatable?_ method.
#
# source://json//lib/json/common.rb#683
class Class < ::Module
  # Returns true if this class can be used to create an instance
  # from a serialised JSON string. The class has to implement a class
  # method _json_create_ that expects a hash as first parameter. The hash
  # should include the required data.
  #
  # @return [Boolean]
  #
  # source://json//lib/json/common.rb#688
  def json_creatable?; end
end

# \Symbol:
#   require 'json/add/symbol'
#   ruby0 = :foo # foo
#   json = JSON.generate(ruby0) # {"json_class":"Symbol","s":"foo"}
#   ruby1 = JSON.parse(json, create_additions: true) # foo
#   ruby1.class # Symbol
#
# \Time:
#   require 'json/add/time'
#   ruby0 = Time.now # 2020-05-02 11:28:26 -0500
#   json = JSON.generate(ruby0) # {"json_class":"Time","s":1588436906,"n":840560000}
#   ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02 11:28:26 -0500
#   ruby1.class # Time
#
#
# === Custom \JSON Additions
#
# In addition to the \JSON additions provided,
# you can craft \JSON additions of your own,
# either for Ruby built-in classes or for user-defined classes.
#
# Here's a user-defined class +Foo+:
#   class Foo
#     attr_accessor :bar, :baz
#     def initialize(bar, baz)
#       self.bar = bar
#       self.baz = baz
#     end
#   end
#
# Here's the \JSON addition for it:
#   # Extend class Foo with JSON addition.
#   class Foo
#     # Serialize Foo object with its class name and arguments
#     def to_json(*args)
#       {
#         JSON.create_id  => self.class.name,
#         'a'             => [ bar, baz ]
#       }.to_json(*args)
#     end
#     # Deserialize JSON string by constructing new Foo object with arguments.
#     def self.json_create(object)
#       new(*object['a'])
#     end
#   end
#
# Demonstration:
#   require 'json'
#   # This Foo object has no custom addition.
#   foo0 = Foo.new(0, 1)
#   json0 = JSON.generate(foo0)
#   obj0 = JSON.parse(json0)
#   # Lood the custom addition.
#   require_relative 'foo_addition'
#   # This foo has the custom addition.
#   foo1 = Foo.new(0, 1)
#   json1 = JSON.generate(foo1)
#   obj1 = JSON.parse(json1, create_additions: true)
#   #   Make a nice display.
#   display = <<EOT
#   Generated JSON:
#     Without custom addition:  #{json0} (#{json0.class})
#     With custom addition:     #{json1} (#{json1.class})
#   Parsed JSON:
#     Without custom addition:  #{obj0.inspect} (#{obj0.class})
#     With custom addition:     #{obj1.inspect} (#{obj1.class})
#   EOT
#   puts display
#
# Output:
#
#   Generated JSON:
#     Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#     With custom addition:     {"json_class":"Foo","a":[0,1]} (String)
#   Parsed JSON:
#     Without custom addition:  "#<Foo:0x0000000006534e80>" (String)
#     With custom addition:     #<Foo:0x0000000006473bb8 @bar=0, @baz=1> (Foo)
#
# source://json//lib/json/version.rb#2
module JSON
  private

  # Dumps _obj_ as a JSON string, i.e. calls generate on the object and returns
  # the result.
  #
  # If anIO (an IO-like object or an object that responds to the write method)
  # was given, the resulting JSON is written to it.
  #
  # If the number of nested arrays or objects exceeds _limit_, an ArgumentError
  # exception is raised. This argument is similar (but not exactly the
  # same!) to the _limit_ argument in Marshal.dump.
  #
  # The default options for the generator can be changed via the
  # dump_default_options method.
  #
  # This method is part of the implementation of the load/dump interface of
  # Marshal and YAML.
  #
  # source://json//lib/json/common.rb#619
  def dump(obj, anIO = T.unsafe(nil), limit = T.unsafe(nil)); end

  # Arguments +obj+ and +opts+ here are the same as
  # arguments +obj+ and +opts+ in JSON.generate.
  #
  # By default, generates \JSON data without checking
  # for circular references in +obj+ (option +max_nesting+ set to +false+, disabled).
  #
  # Raises an exception if +obj+ contains circular references:
  #   a = []; b = []; a.push(b); b.push(a)
  #   # Raises SystemStackError (stack level too deep):
  #   JSON.fast_generate(a)
  #
  # source://json//lib/json/common.rb#450
  def fast_generate(obj, opts = T.unsafe(nil)); end

  # :stopdoc:
  # I want to deprecate these later, so I'll first be silent about them, and later delete them.
  #
  # source://json//lib/json/common.rb#450
  def fast_unparse(obj, opts = T.unsafe(nil)); end

  # :call-seq:
  #   JSON.generate(obj, opts = nil) -> new_string
  #
  # Argument +obj+ is the Ruby object to be converted to \JSON.
  #
  # Argument +opts+, if given, contains options for the generation, and must be a
  # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects]
  # (implementing +to_hash+).
  #
  # Returns a \String containing the generated \JSON data.
  #
  # See also JSON.fast_generate, JSON.pretty_generate.
  #
  # ---
  #
  # When +obj+ is an
  # {Array-convertible object}[doc/implicit_conversion_rdoc.html#label-Array-Convertible+Objects]
  # (implementing +to_ary+), returns a \String containing a \JSON array:
  #   obj = ["foo", 1.0, true, false, nil]
  #   json = JSON.generate(obj)
  #   json # => '["foo",1.0,true,false,null]'
  #
  # When +obj+ is a
  # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects],
  # return a \String containing a \JSON object:
  #   obj = {foo: 0, bar: 's', baz: :bat}
  #   json = JSON.generate(obj)
  #   json # => '{"foo":0,"bar":"s","baz":"bat"}'
  #
  # For examples of generating from other Ruby objects, see
  # {Generating \JSON from Other Objects}[#module-JSON-label-Generating+JSON+from+Other+Objects].
  #
  # ====== Input Options
  #
  # Option +allow_nan+ (boolean) specifies whether
  # +NaN+, +Infinity+, and <tt>-Infinity</tt> may be generated;
  # defaults to +false+.
  #
  # With the default, +false+:
  #   # Raises JSON::GeneratorError (920: NaN not allowed in JSON):
  #   JSON.generate(JSON::NaN)
  #   # Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
  #   JSON.generate(JSON::Infinity)
  #   # Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
  #   JSON.generate(JSON::MinusInfinity)
  #
  # Allow:
  #   ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
  #   JSON.generate(ruby, allow_nan: true) # => '[NaN,Infinity,-Infinity]'
  #
  # ---
  #
  # Option +max_nesting+ (\Integer) specifies the maximum nesting depth
  # in +obj+; defaults to +100+.
  #
  # With the default, +100+:
  #   obj = [[[[[[0]]]]]]
  #   JSON.generate(obj) # => '[[[[[[0]]]]]]'
  #
  # Too deep:
  #   # Raises JSON::NestingError (nesting of 2 is too deep):
  #   JSON.generate(obj, max_nesting: 2)
  #
  # ====== Output Options
  #
  # The default formatting options generate the most compact
  # \JSON data, all on one line and with no whitespace.
  #
  # You can use these formatting options to generate
  # \JSON data in a more open format, using whitespace.
  # See also JSON.pretty_generate.
  #
  # - Option +array_nl+ (\String) specifies a string (usually a newline)
  #   to be inserted after each \JSON array; defaults to the empty \String, <tt>''</tt>.
  # - Option +object_nl+ (\String) specifies a string (usually a newline)
  #   to be inserted after each \JSON object; defaults to the empty \String, <tt>''</tt>.
  # - Option +indent+ (\String) specifies the string (usually spaces) to be
  #   used for indentation; defaults to the empty \String, <tt>''</tt>;
  #   defaults to the empty \String, <tt>''</tt>;
  #   has no effect unless options +array_nl+ or +object_nl+ specify newlines.
  # - Option +space+ (\String) specifies a string (usually a space) to be
  #   inserted after the colon in each \JSON object's pair;
  #   defaults to the empty \String, <tt>''</tt>.
  # - Option +space_before+ (\String) specifies a string (usually a space) to be
  #   inserted before the colon in each \JSON object's pair;
  #   defaults to the empty \String, <tt>''</tt>.
  #
  # In this example, +obj+ is used first to generate the shortest
  # \JSON data (no whitespace), then again with all formatting options
  # specified:
  #
  #   obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
  #   json = JSON.generate(obj)
  #   puts 'Compact:', json
  #   opts = {
  #     array_nl: "\n",
  #     object_nl: "\n",
  #     indent+: '  ',
  #     space_before: ' ',
  #     space: ' '
  #   }
  #   puts 'Open:', JSON.generate(obj, opts)
  #
  # Output:
  #   Compact:
  #   {"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
  #   Open:
  #   {
  #     "foo" : [
  #       "bar",
  #       "baz"
  #   ],
  #     "bat" : {
  #       "bam" : 0,
  #       "bad" : 1
  #     }
  #   }
  #
  # ---
  #
  # Raises an exception if any formatting option is not a \String.
  #
  # ====== Exceptions
  #
  # Raises an exception if +obj+ contains circular references:
  #   a = []; b = []; a.push(b); b.push(a)
  #   # Raises JSON::NestingError (nesting of 100 is too deep):
  #   JSON.generate(a)
  #
  # source://json//lib/json/common.rb#414
  def generate(obj, opts = T.unsafe(nil)); end

  # Load a ruby data structure from a JSON _source_ and return it. A source can
  # either be a string-like object, an IO-like object, or an object responding
  # to the read method. If _proc_ was given, it will be called with any nested
  # Ruby object as an argument recursively in depth first order. To modify the
  # default options pass in the optional _options_ argument as well.
  #
  # BEWARE: This method is meant to serialise data from trusted user input,
  # like from your own database server or clients under your control, it could
  # be dangerous to allow untrusted users to pass JSON sources into it. The
  # default options for the parser can be changed via the load_default_options
  # method.
  #
  # This method is part of the implementation of the load/dump interface of
  # Marshal and YAML.
  #
  # source://json//lib/json/common.rb#558
  def load(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end

  # :call-seq:
  #   JSON.parse(source, opts) -> object
  #
  # Argument +source+ contains the \String to be parsed. It must be a
  # {String-convertible object}[doc/implicit_conversion_rdoc.html#label-String-Convertible+Objects]
  # (implementing +to_str+), and must contain valid \JSON data.
  #
  # Argument +opts+, if given, contains options for the parsing, and must be a
  # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects]
  # (implementing +to_hash+).
  #
  # Returns the Ruby objects created by parsing the given +source+.
  #
  # ---
  #
  # When +source+ is a \JSON array, returns a Ruby \Array:
  #   source = '["foo", 1.0, true, false, null]'
  #   ruby = JSON.parse(source)
  #   ruby # => ["foo", 1.0, true, false, nil]
  #   ruby.class # => Array
  #
  # When +source+ is a \JSON object, returns a Ruby \Hash:
  #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
  #   ruby = JSON.parse(source)
  #   ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
  #   ruby.class # => Hash
  #
  # For examples of parsing for all \JSON data types, see
  # {Parsing \JSON}[#module-JSON-label-Parsing+JSON].
  #
  # ====== Input Options
  #
  # Option +max_nesting+ (\Integer) specifies the maximum nesting depth allowed;
  # defaults to +100+; specify +false+ to disable depth checking.
  #
  # With the default, +false+:
  #   source = '[0, [1, [2, [3]]]]'
  #   ruby = JSON.parse(source)
  #   ruby # => [0, [1, [2, [3]]]]
  # Too deep:
  #   # Raises JSON::NestingError (nesting of 2 is too deep):
  #   JSON.parse(source, {max_nesting: 1})
  # Bad value:
  #   # Raises TypeError (wrong argument type Symbol (expected Fixnum)):
  #   JSON.parse(source, {max_nesting: :foo})
  #
  # ---
  #
  # Option +allow_nan+ (boolean) specifies whether to allow
  # NaN, Infinity, and MinusInfinity in +source+;
  # defaults to +false+.
  #
  # With the default, +false+:
  #   # Raises JSON::ParserError (225: unexpected token at '[NaN]'):
  #   JSON.parse('[NaN]')
  #   # Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
  #   JSON.parse('[Infinity]')
  #   # Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
  #   JSON.parse('[-Infinity]')
  # Allow:
  #   source = '[NaN, Infinity, -Infinity]'
  #   ruby = JSON.parse(source, {allow_nan: true})
  #   ruby # => [NaN, Infinity, -Infinity]
  #
  # ====== Output Options
  #
  # Option +symbolize_names+ (boolean) specifies whether returned \Hash keys
  # should be Symbols;
  # defaults to +false+ (use Strings).
  #
  # With the default, +false+:
  #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
  #   ruby = JSON.parse(source)
  #   ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
  # Use Symbols:
  #   ruby = JSON.parse(source, {symbolize_names: true})
  #   ruby # => {:a=>"foo", :b=>1.0, :c=>true, :d=>false, :e=>nil}
  #
  # ---
  #
  # Option +object_class+ (\Class) specifies the Ruby class to be used
  # for each \JSON object;
  # defaults to \Hash.
  #
  # With the default, \Hash:
  #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
  #   ruby = JSON.parse(source)
  #   ruby.class # => Hash
  # Use class \OpenStruct:
  #   ruby = JSON.parse(source, {object_class: OpenStruct})
  #   ruby # => #<OpenStruct a="foo", b=1.0, c=true, d=false, e=nil>
  #
  # ---
  #
  # Option +array_class+ (\Class) specifies the Ruby class to be used
  # for each \JSON array;
  # defaults to \Array.
  #
  # With the default, \Array:
  #   source = '["foo", 1.0, true, false, null]'
  #   ruby = JSON.parse(source)
  #   ruby.class # => Array
  # Use class \Set:
  #   ruby = JSON.parse(source, {array_class: Set})
  #   ruby # => #<Set: {"foo", 1.0, true, false, nil}>
  #
  # ---
  #
  # Option +create_additions+ (boolean) specifies whether to use \JSON additions in parsing.
  # See {\JSON Additions}[#module-JSON-label-JSON+Additions].
  #
  # ====== Exceptions
  #
  # Raises an exception if +source+ is not valid JSON:
  #
  #   # Raises JSON::ParserError (783: unexpected token at ''):
  #   JSON.parse('')
  #
  # source://json//lib/json/common.rb#262
  def parse(source, opts = T.unsafe(nil)); end

  # :call-seq:
  #   JSON.parse!(source, opts) -> object
  #
  # Calls
  #   parse(source, opts)
  # with +source+ and possibly modified +opts+.
  #
  # Differences from JSON.parse:
  # - Option +max_nesting+, if not provided, defaults to +false+,
  #   which disables checking for nesting depth.
  # - Option +allow_nan+, if not provided, defaults to +true+.
  #
  # source://json//lib/json/common.rb#277
  def parse!(source, opts = T.unsafe(nil)); end

  # :call-seq:
  #   JSON.pretty_generate(obj, opts = nil) -> new_string
  #
  # Arguments +obj+ and +opts+ here are the same as
  # arguments +obj+ and +opts+ in JSON.generate.
  #
  # Default options are:
  #   {
  #     indent: '  ',   # Two spaces
  #     space: ' ',     # One space
  #     array_nl: "\n", # Newline
  #     object_nl: "\n" # Newline
  #   }
  #
  # Example:
  #   obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
  #   json = JSON.pretty_generate(obj)
  #   puts json
  # Output:
  #   {
  #     "foo": [
  #       "bar",
  #       "baz"
  #     ],
  #     "bat": {
  #       "bam": 0,
  #       "bad": 1
  #     }
  #   }
  #
  # source://json//lib/json/common.rb#505
  def pretty_generate(obj, opts = T.unsafe(nil)); end

  # :stopdoc:
  # I want to deprecate these later, so I'll first be silent about them, and later delete them.
  #
  # source://json//lib/json/common.rb#505
  def pretty_unparse(obj, opts = T.unsafe(nil)); end

  # Recursively calls passed _Proc_ if the parsed data structure is an _Array_ or _Hash_
  #
  # source://json//lib/json/common.rb#576
  def recurse_proc(result, &proc); end

  # source://json//lib/json/common.rb#558
  def restore(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end

  # :stopdoc:
  # I want to deprecate these later, so I'll first be silent about them, and
  # later delete them.
  #
  # source://json//lib/json/common.rb#414
  def unparse(obj, opts = T.unsafe(nil)); end

  class << self
    # If +object+ is a
    # {String-convertible object}[doc/implicit_conversion_rdoc.html#label-String-Convertible+Objects]
    # (implementing +to_str+), calls JSON.parse with +object+ and +opts+:
    #   json = '[0, 1, null]'
    #   JSON[json]# => [0, 1, nil]
    #
    # Otherwise, calls JSON.generate with +object+ and +opts+:
    #   ruby = [0, 1, nil]
    #   JSON[ruby] # => '[0,1,null]'
    #
    # source://json//lib/json/common.rb#16
    def [](object, opts = T.unsafe(nil)); end

    # Sets or returns create identifier, which is used to decide if the _json_create_
    # hook of a class should be called; initial value is +json_class+:
    #   JSON.create_id # => 'json_class'
    #
    # source://json//lib/json/common.rb#103
    def create_id; end

    # Sets or returns create identifier, which is used to decide if the _json_create_
    # hook of a class should be called; initial value is +json_class+:
    #   JSON.create_id # => 'json_class'
    #
    # source://json//lib/json/common.rb#103
    def create_id=(_arg0); end

    # Return the constant located at _path_. The format of _path_ has to be
    # either ::A::B::C or A::B::C. In any case, A has to be located at the top
    # level (absolute namespace path?). If there doesn't exist a constant at
    # the given path, an ArgumentError is raised.
    #
    # source://json//lib/json/common.rb#40
    def deep_const_get(path); end

    # Dumps _obj_ as a JSON string, i.e. calls generate on the object and returns
    # the result.
    #
    # If anIO (an IO-like object or an object that responds to the write method)
    # was given, the resulting JSON is written to it.
    #
    # If the number of nested arrays or objects exceeds _limit_, an ArgumentError
    # exception is raised. This argument is similar (but not exactly the
    # same!) to the _limit_ argument in Marshal.dump.
    #
    # The default options for the generator can be changed via the
    # dump_default_options method.
    #
    # This method is part of the implementation of the load/dump interface of
    # Marshal and YAML.
    #
    # source://json//lib/json/common.rb#619
    def dump(obj, anIO = T.unsafe(nil), limit = T.unsafe(nil)); end

    # Sets or returns the default options for the JSON.dump method.
    # Initially:
    #   opts = JSON.dump_default_options
    #   opts # => {:max_nesting=>false, :allow_nan=>true}
    #
    # source://json//lib/json/common.rb#597
    def dump_default_options; end

    # Sets or returns the default options for the JSON.dump method.
    # Initially:
    #   opts = JSON.dump_default_options
    #   opts # => {:max_nesting=>false, :allow_nan=>true}
    #
    # source://json//lib/json/common.rb#597
    def dump_default_options=(_arg0); end

    # Arguments +obj+ and +opts+ here are the same as
    # arguments +obj+ and +opts+ in JSON.generate.
    #
    # By default, generates \JSON data without checking
    # for circular references in +obj+ (option +max_nesting+ set to +false+, disabled).
    #
    # Raises an exception if +obj+ contains circular references:
    #   a = []; b = []; a.push(b); b.push(a)
    #   # Raises SystemStackError (stack level too deep):
    #   JSON.fast_generate(a)
    #
    # source://json//lib/json/common.rb#450
    def fast_generate(obj, opts = T.unsafe(nil)); end

    # :stopdoc:
    # I want to deprecate these later, so I'll first be silent about them, and later delete them.
    #
    # source://json//lib/json/common.rb#450
    def fast_unparse(obj, opts = T.unsafe(nil)); end

    # :call-seq:
    #   JSON.generate(obj, opts = nil) -> new_string
    #
    # Argument +obj+ is the Ruby object to be converted to \JSON.
    #
    # Argument +opts+, if given, contains options for the generation, and must be a
    # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects]
    # (implementing +to_hash+).
    #
    # Returns a \String containing the generated \JSON data.
    #
    # See also JSON.fast_generate, JSON.pretty_generate.
    #
    # ---
    #
    # When +obj+ is an
    # {Array-convertible object}[doc/implicit_conversion_rdoc.html#label-Array-Convertible+Objects]
    # (implementing +to_ary+), returns a \String containing a \JSON array:
    #   obj = ["foo", 1.0, true, false, nil]
    #   json = JSON.generate(obj)
    #   json # => '["foo",1.0,true,false,null]'
    #
    # When +obj+ is a
    # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects],
    # return a \String containing a \JSON object:
    #   obj = {foo: 0, bar: 's', baz: :bat}
    #   json = JSON.generate(obj)
    #   json # => '{"foo":0,"bar":"s","baz":"bat"}'
    #
    # For examples of generating from other Ruby objects, see
    # {Generating \JSON from Other Objects}[#module-JSON-label-Generating+JSON+from+Other+Objects].
    #
    # ====== Input Options
    #
    # Option +allow_nan+ (boolean) specifies whether
    # +NaN+, +Infinity+, and <tt>-Infinity</tt> may be generated;
    # defaults to +false+.
    #
    # With the default, +false+:
    #   # Raises JSON::GeneratorError (920: NaN not allowed in JSON):
    #   JSON.generate(JSON::NaN)
    #   # Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
    #   JSON.generate(JSON::Infinity)
    #   # Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
    #   JSON.generate(JSON::MinusInfinity)
    #
    # Allow:
    #   ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
    #   JSON.generate(ruby, allow_nan: true) # => '[NaN,Infinity,-Infinity]'
    #
    # ---
    #
    # Option +max_nesting+ (\Integer) specifies the maximum nesting depth
    # in +obj+; defaults to +100+.
    #
    # With the default, +100+:
    #   obj = [[[[[[0]]]]]]
    #   JSON.generate(obj) # => '[[[[[[0]]]]]]'
    #
    # Too deep:
    #   # Raises JSON::NestingError (nesting of 2 is too deep):
    #   JSON.generate(obj, max_nesting: 2)
    #
    # ====== Output Options
    #
    # The default formatting options generate the most compact
    # \JSON data, all on one line and with no whitespace.
    #
    # You can use these formatting options to generate
    # \JSON data in a more open format, using whitespace.
    # See also JSON.pretty_generate.
    #
    # - Option +array_nl+ (\String) specifies a string (usually a newline)
    #   to be inserted after each \JSON array; defaults to the empty \String, <tt>''</tt>.
    # - Option +object_nl+ (\String) specifies a string (usually a newline)
    #   to be inserted after each \JSON object; defaults to the empty \String, <tt>''</tt>.
    # - Option +indent+ (\String) specifies the string (usually spaces) to be
    #   used for indentation; defaults to the empty \String, <tt>''</tt>;
    #   defaults to the empty \String, <tt>''</tt>;
    #   has no effect unless options +array_nl+ or +object_nl+ specify newlines.
    # - Option +space+ (\String) specifies a string (usually a space) to be
    #   inserted after the colon in each \JSON object's pair;
    #   defaults to the empty \String, <tt>''</tt>.
    # - Option +space_before+ (\String) specifies a string (usually a space) to be
    #   inserted before the colon in each \JSON object's pair;
    #   defaults to the empty \String, <tt>''</tt>.
    #
    # In this example, +obj+ is used first to generate the shortest
    # \JSON data (no whitespace), then again with all formatting options
    # specified:
    #
    #   obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
    #   json = JSON.generate(obj)
    #   puts 'Compact:', json
    #   opts = {
    #     array_nl: "\n",
    #     object_nl: "\n",
    #     indent+: '  ',
    #     space_before: ' ',
    #     space: ' '
    #   }
    #   puts 'Open:', JSON.generate(obj, opts)
    #
    # Output:
    #   Compact:
    #   {"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
    #   Open:
    #   {
    #     "foo" : [
    #       "bar",
    #       "baz"
    #   ],
    #     "bat" : {
    #       "bam" : 0,
    #       "bad" : 1
    #     }
    #   }
    #
    # ---
    #
    # Raises an exception if any formatting option is not a \String.
    #
    # ====== Exceptions
    #
    # Raises an exception if +obj+ contains circular references:
    #   a = []; b = []; a.push(b); b.push(a)
    #   # Raises JSON::NestingError (nesting of 100 is too deep):
    #   JSON.generate(a)
    #
    # source://json//lib/json/common.rb#414
    def generate(obj, opts = T.unsafe(nil)); end

    # Returns the JSON generator module that is used by JSON. This is
    # either JSON::Ext::Generator or JSON::Pure::Generator:
    #   JSON.generator # => JSON::Ext::Generator
    #
    # source://json//lib/json/common.rb#93
    def generator; end

    # Set the module _generator_ to be used by JSON.
    #
    # source://json//lib/json/common.rb#56
    def generator=(generator); end

    # Encodes string using String.encode.
    #
    # source://json//lib/json/common.rb#641
    def iconv(to, from, string); end

    # Load a ruby data structure from a JSON _source_ and return it. A source can
    # either be a string-like object, an IO-like object, or an object responding
    # to the read method. If _proc_ was given, it will be called with any nested
    # Ruby object as an argument recursively in depth first order. To modify the
    # default options pass in the optional _options_ argument as well.
    #
    # BEWARE: This method is meant to serialise data from trusted user input,
    # like from your own database server or clients under your control, it could
    # be dangerous to allow untrusted users to pass JSON sources into it. The
    # default options for the parser can be changed via the load_default_options
    # method.
    #
    # This method is part of the implementation of the load/dump interface of
    # Marshal and YAML.
    #
    # source://json//lib/json/common.rb#558
    def load(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end

    # Sets or returns default options for the JSON.load method.
    # Initially:
    #   opts = JSON.load_default_options
    #   opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
    #
    # source://json//lib/json/common.rb#535
    def load_default_options; end

    # Sets or returns default options for the JSON.load method.
    # Initially:
    #   opts = JSON.load_default_options
    #   opts # => {:max_nesting=>false, :allow_nan=>true, :allow_blank=>true, :create_additions=>true}
    #
    # source://json//lib/json/common.rb#535
    def load_default_options=(_arg0); end

    # :call-seq:
    #   JSON.parse(source, opts) -> object
    #
    # Argument +source+ contains the \String to be parsed. It must be a
    # {String-convertible object}[doc/implicit_conversion_rdoc.html#label-String-Convertible+Objects]
    # (implementing +to_str+), and must contain valid \JSON data.
    #
    # Argument +opts+, if given, contains options for the parsing, and must be a
    # {Hash-convertible object}[doc/implicit_conversion_rdoc.html#label-Hash-Convertible+Objects]
    # (implementing +to_hash+).
    #
    # Returns the Ruby objects created by parsing the given +source+.
    #
    # ---
    #
    # When +source+ is a \JSON array, returns a Ruby \Array:
    #   source = '["foo", 1.0, true, false, null]'
    #   ruby = JSON.parse(source)
    #   ruby # => ["foo", 1.0, true, false, nil]
    #   ruby.class # => Array
    #
    # When +source+ is a \JSON object, returns a Ruby \Hash:
    #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    #   ruby = JSON.parse(source)
    #   ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
    #   ruby.class # => Hash
    #
    # For examples of parsing for all \JSON data types, see
    # {Parsing \JSON}[#module-JSON-label-Parsing+JSON].
    #
    # ====== Input Options
    #
    # Option +max_nesting+ (\Integer) specifies the maximum nesting depth allowed;
    # defaults to +100+; specify +false+ to disable depth checking.
    #
    # With the default, +false+:
    #   source = '[0, [1, [2, [3]]]]'
    #   ruby = JSON.parse(source)
    #   ruby # => [0, [1, [2, [3]]]]
    # Too deep:
    #   # Raises JSON::NestingError (nesting of 2 is too deep):
    #   JSON.parse(source, {max_nesting: 1})
    # Bad value:
    #   # Raises TypeError (wrong argument type Symbol (expected Fixnum)):
    #   JSON.parse(source, {max_nesting: :foo})
    #
    # ---
    #
    # Option +allow_nan+ (boolean) specifies whether to allow
    # NaN, Infinity, and MinusInfinity in +source+;
    # defaults to +false+.
    #
    # With the default, +false+:
    #   # Raises JSON::ParserError (225: unexpected token at '[NaN]'):
    #   JSON.parse('[NaN]')
    #   # Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
    #   JSON.parse('[Infinity]')
    #   # Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
    #   JSON.parse('[-Infinity]')
    # Allow:
    #   source = '[NaN, Infinity, -Infinity]'
    #   ruby = JSON.parse(source, {allow_nan: true})
    #   ruby # => [NaN, Infinity, -Infinity]
    #
    # ====== Output Options
    #
    # Option +symbolize_names+ (boolean) specifies whether returned \Hash keys
    # should be Symbols;
    # defaults to +false+ (use Strings).
    #
    # With the default, +false+:
    #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    #   ruby = JSON.parse(source)
    #   ruby # => {"a"=>"foo", "b"=>1.0, "c"=>true, "d"=>false, "e"=>nil}
    # Use Symbols:
    #   ruby = JSON.parse(source, {symbolize_names: true})
    #   ruby # => {:a=>"foo", :b=>1.0, :c=>true, :d=>false, :e=>nil}
    #
    # ---
    #
    # Option +object_class+ (\Class) specifies the Ruby class to be used
    # for each \JSON object;
    # defaults to \Hash.
    #
    # With the default, \Hash:
    #   source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
    #   ruby = JSON.parse(source)
    #   ruby.class # => Hash
    # Use class \OpenStruct:
    #   ruby = JSON.parse(source, {object_class: OpenStruct})
    #   ruby # => #<OpenStruct a="foo", b=1.0, c=true, d=false, e=nil>
    #
    # ---
    #
    # Option +array_class+ (\Class) specifies the Ruby class to be used
    # for each \JSON array;
    # defaults to \Array.
    #
    # With the default, \Array:
    #   source = '["foo", 1.0, true, false, null]'
    #   ruby = JSON.parse(source)
    #   ruby.class # => Array
    # Use class \Set:
    #   ruby = JSON.parse(source, {array_class: Set})
    #   ruby # => #<Set: {"foo", 1.0, true, false, nil}>
    #
    # ---
    #
    # Option +create_additions+ (boolean) specifies whether to use \JSON additions in parsing.
    # See {\JSON Additions}[#module-JSON-label-JSON+Additions].
    #
    # ====== Exceptions
    #
    # Raises an exception if +source+ is not valid JSON:
    #
    #   # Raises JSON::ParserError (783: unexpected token at ''):
    #   JSON.parse('')
    #
    # source://json//lib/json/common.rb#262
    def parse(source, opts = T.unsafe(nil)); end

    # :call-seq:
    #   JSON.parse!(source, opts) -> object
    #
    # Calls
    #   parse(source, opts)
    # with +source+ and possibly modified +opts+.
    #
    # Differences from JSON.parse:
    # - Option +max_nesting+, if not provided, defaults to +false+,
    #   which disables checking for nesting depth.
    # - Option +allow_nan+, if not provided, defaults to +true+.
    #
    # source://json//lib/json/common.rb#277
    def parse!(source, opts = T.unsafe(nil)); end

    # Returns the JSON parser class that is used by JSON. This is either
    # JSON::Ext::Parser or JSON::Pure::Parser:
    #   JSON.parser # => JSON::Ext::Parser
    #
    # source://json//lib/json/common.rb#27
    def parser; end

    # Set the JSON parser class _parser_ to be used by JSON.
    #
    # source://json//lib/json/common.rb#30
    def parser=(parser); end

    # :call-seq:
    #   JSON.pretty_generate(obj, opts = nil) -> new_string
    #
    # Arguments +obj+ and +opts+ here are the same as
    # arguments +obj+ and +opts+ in JSON.generate.
    #
    # Default options are:
    #   {
    #     indent: '  ',   # Two spaces
    #     space: ' ',     # One space
    #     array_nl: "\n", # Newline
    #     object_nl: "\n" # Newline
    #   }
    #
    # Example:
    #   obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
    #   json = JSON.pretty_generate(obj)
    #   puts json
    # Output:
    #   {
    #     "foo": [
    #       "bar",
    #       "baz"
    #     ],
    #     "bat": {
    #       "bam": 0,
    #       "bad": 1
    #     }
    #   }
    #
    # source://json//lib/json/common.rb#505
    def pretty_generate(obj, opts = T.unsafe(nil)); end

    # :stopdoc:
    # I want to deprecate these later, so I'll first be silent about them, and later delete them.
    #
    # source://json//lib/json/common.rb#505
    def pretty_unparse(obj, opts = T.unsafe(nil)); end

    # Recursively calls passed _Proc_ if the parsed data structure is an _Array_ or _Hash_
    #
    # source://json//lib/json/common.rb#576
    def recurse_proc(result, &proc); end

    # source://json//lib/json/common.rb#558
    def restore(source, proc = T.unsafe(nil), options = T.unsafe(nil)); end

    # Sets or Returns the JSON generator state class that is used by JSON. This is
    # either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
    #   JSON.state # => JSON::Ext::Generator::State
    #
    # source://json//lib/json/common.rb#98
    def state; end

    # Sets or Returns the JSON generator state class that is used by JSON. This is
    # either JSON::Ext::Generator::State or JSON::Pure::Generator::State:
    #   JSON.state # => JSON::Ext::Generator::State
    #
    # source://json//lib/json/common.rb#98
    def state=(_arg0); end

    # :stopdoc:
    # I want to deprecate these later, so I'll first be silent about them, and
    # later delete them.
    #
    # source://json//lib/json/common.rb#414
    def unparse(obj, opts = T.unsafe(nil)); end
  end
end

# source://json//lib/json/generic_object.rb#5
class JSON::GenericObject < ::OpenStruct
  # source://json//lib/json/generic_object.rb#63
  def as_json(*_arg0); end

  # source://json//lib/json/generic_object.rb#47
  def to_hash; end

  # source://json//lib/json/generic_object.rb#67
  def to_json(*a); end

  # source://json//lib/json/generic_object.rb#59
  def |(other); end

  class << self
    # source://json//lib/json/generic_object.rb#41
    def dump(obj, *args); end

    # source://json//lib/json/generic_object.rb#21
    def from_hash(object); end

    # Sets the attribute json_creatable
    #
    # @param value the value to set the attribute json_creatable to.
    #
    # source://json//lib/json/generic_object.rb#13
    def json_creatable=(_arg0); end

    # @return [Boolean]
    #
    # source://json//lib/json/generic_object.rb#9
    def json_creatable?; end

    # source://json//lib/json/generic_object.rb#15
    def json_create(data); end

    # source://json//lib/json/generic_object.rb#36
    def load(source, proc = T.unsafe(nil), opts = T.unsafe(nil)); end
  end
end

# The base exception for JSON errors.
#
# source://json//lib/json/common.rb#114
class JSON::JSONError < ::StandardError
  class << self
    # source://json//lib/json/common.rb#115
    def wrap(exception); end
  end
end

# source://json//lib/json/common.rb#33
JSON::Parser = JSON::Ext::Parser

# source://json//lib/json/common.rb#71
JSON::State = JSON::Ext::Generator::State

# For backwards compatibility
#
# source://json//lib/json/common.rb#136
JSON::UnparserError = JSON::GeneratorError

# source://json//lib/json/common.rb#646
module Kernel
  private

  # If _object_ is string-like, parse the string and return the parsed result as
  # a Ruby data structure. Otherwise, generate a JSON text from the Ruby data
  # structure object and return it.
  #
  # The _opts_ argument is passed through to generate/parse respectively. See
  # generate and parse for their documentation.
  #
  # source://json//lib/json/common.rb#673
  def JSON(object, *args); end

  # Outputs _objs_ to STDOUT as JSON strings in the shortest form, that is in
  # one line.
  #
  # source://json//lib/json/common.rb#651
  def j(*objs); end

  # Outputs _objs_ to STDOUT as JSON strings in a pretty format, with
  # indentation and over many lines.
  #
  # source://json//lib/json/common.rb#660
  def jj(*objs); end
end
