# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `connection_pool` gem.
# Please instead update this file by running `bin/tapioca gem connection_pool`.

# Generic connection pool class for e.g. sharing a limited number of network connections
# among many threads.  Note: Connections are lazily created.
#
# Example usage with block (faster):
#
#    @pool = ConnectionPool.new { Redis.new }
#
#    @pool.with do |redis|
#      redis.lpop('my-list') if redis.llen('my-list') > 0
#    end
#
# Using optional timeout override (for that single invocation)
#
#    @pool.with(timeout: 2.0) do |redis|
#      redis.lpop('my-list') if redis.llen('my-list') > 0
#    end
#
# Example usage replacing an existing connection (slower):
#
#    $redis = ConnectionPool.wrap { Redis.new }
#
#    def do_work
#      $redis.lpop('my-list') if $redis.llen('my-list') > 0
#    end
#
# Accepts the following options:
# - :size - number of connections to pool, defaults to 5
# - :timeout - amount of time to wait for a connection if none currently available, defaults to 5 seconds
#
# source://connection_pool//lib/connection_pool/version.rb#1
class ConnectionPool
  # @raise [ArgumentError]
  # @return [ConnectionPool] a new instance of ConnectionPool
  #
  # source://connection_pool//lib/connection_pool.rb#44
  def initialize(options = T.unsafe(nil), &block); end

  # Number of pool entries available for checkout at this instant.
  #
  # source://connection_pool//lib/connection_pool.rb#122
  def available; end

  # source://connection_pool//lib/connection_pool.rb#97
  def checkin; end

  # source://connection_pool//lib/connection_pool.rb#87
  def checkout(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#112
  def shutdown(&block); end

  # Size of this connection pool
  #
  # source://connection_pool//lib/connection_pool.rb#117
  def size; end

  # jruby 1.7.x
  #
  # source://connection_pool//lib/connection_pool.rb#60
  def with(options = T.unsafe(nil)); end

  class << self
    # Returns the current time a tracked by the application monotonic clock.
    #
    # @return [Float] The current monotonic time when `since` not given else
    #   the elapsed monotonic time between `since` and the current time
    #
    # source://connection_pool//lib/connection_pool/monotonic_time.rb#62
    def monotonic_time; end

    # source://connection_pool//lib/connection_pool.rb#40
    def wrap(options, &block); end
  end
end

# source://connection_pool//lib/connection_pool.rb#35
ConnectionPool::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://connection_pool//lib/connection_pool.rb#37
class ConnectionPool::Error < ::RuntimeError; end

# Clock that cannot be set and represents monotonic time since
# some unspecified starting point.
#
# source://connection_pool//lib/connection_pool/monotonic_time.rb#53
ConnectionPool::GLOBAL_MONOTONIC_CLOCK = T.let(T.unsafe(nil), T.untyped)

# Raised when you attempt to retrieve a connection from a pool that has been
# shut down.
#
# source://connection_pool//lib/connection_pool/timed_stack.rb#9
class ConnectionPool::PoolShuttingDownError < ::RuntimeError; end

# Examples:
#
#    ts = TimedStack.new(1) { MyConnection.new }
#
#    # fetch a connection
#    conn = ts.pop
#
#    # return a connection
#    ts.push conn
#
#    conn = ts.pop
#    ts.pop timeout: 5
#    #=> raises Timeout::Error after 5 seconds
#
# source://connection_pool//lib/connection_pool/timed_stack.rb#30
class ConnectionPool::TimedStack
  # Creates a new pool with +size+ connections that are created from the given
  # +block+.
  #
  # @return [TimedStack] a new instance of TimedStack
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#37
  def initialize(size = T.unsafe(nil), &block); end

  # Returns +obj+ to the stack.  +options+ is ignored in TimedStack but may be
  # used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#51
  def <<(obj, options = T.unsafe(nil)); end

  # Returns +true+ if there are no available connections.
  #
  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#111
  def empty?; end

  # The number of connections available on the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#118
  def length; end

  # Returns the value of attribute max.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#31
  def max; end

  # Retrieves a connection from the stack.  If a connection is available it is
  # immediately returned.  If no connection is available within the given
  # timeout a Timeout::Error is raised.
  #
  # +:timeout+ is the only checked entry in +options+ and is preferred over
  # the +timeout+ argument (which will be removed in a future release).  Other
  # options may be used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#73
  def pop(timeout = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns +obj+ to the stack.  +options+ is ignored in TimedStack but may be
  # used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#51
  def push(obj, options = T.unsafe(nil)); end

  # Shuts down the TimedStack which prevents connections from being checked
  # out.  The +block+ is called once for each connection on the stack.
  #
  # @raise [ArgumentError]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#97
  def shutdown(&block); end

  private

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must returns true if a connection is available on the stack.
  #
  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#129
  def connection_stored?(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must return a connection from the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#138
  def fetch_connection(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must shut down all connections on the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#147
  def shutdown_connections(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must return +obj+ to the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#159
  def store_connection(obj, options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must create a connection if and only if the total number of
  # connections allowed has not been met.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#169
  def try_create(options = T.unsafe(nil)); end
end

# source://connection_pool//lib/connection_pool/version.rb#2
ConnectionPool::VERSION = T.let(T.unsafe(nil), String)

# source://connection_pool//lib/connection_pool.rb#128
class ConnectionPool::Wrapper < ::BasicObject
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://connection_pool//lib/connection_pool.rb#131
  def initialize(options = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool.rb#155
  def method_missing(name, *args, &block); end

  # source://connection_pool//lib/connection_pool.rb#147
  def pool_available; end

  # source://connection_pool//lib/connection_pool.rb#139
  def pool_shutdown(&block); end

  # source://connection_pool//lib/connection_pool.rb#143
  def pool_size; end

  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool.rb#151
  def respond_to?(id, *args); end

  # source://connection_pool//lib/connection_pool.rb#135
  def with(&block); end
end

# source://connection_pool//lib/connection_pool.rb#129
ConnectionPool::Wrapper::METHODS = T.let(T.unsafe(nil), Array)
